<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/x-icon" href="favicon.ico" />
    <title>SAR Pearl Drop Simulator</title>

    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        background: linear-gradient(135deg, #0f0f1e 0%, #1a1a2e 50%, #16213e 100%);
        color: #e8e8e8;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', sans-serif;
        padding: 40px 20px;
        min-height: 100vh;
        line-height: 1.6;
      }

      h1 {
        background: linear-gradient(135deg, #ffd369 0%, #ffb347 50%, #ffd369 100%);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        text-align: center;
        font-size: 2.5rem;
        font-weight: 700;
        margin-bottom: 40px;
        letter-spacing: -0.5px;
      }

      h3 {
        font-size: 1.25rem;
        font-weight: 600;
        margin-bottom: 16px;
        letter-spacing: 0.3px;
      }

      label {
        display: block;
        color: #b8b8b8;
        font-size: 0.9rem;
        font-weight: 500;
        margin-top: 12px;
        margin-bottom: 2px;
        letter-spacing: 0.2px;
      }

      label:first-of-type {
        margin-top: 16px;
      }

      .config-box p {
        margin-bottom: 20px;
      }

      br {
        line-height: 0;
        margin: 0;
        padding: 0;
      }

      /* TOP LAYOUT */
      .top-layout {
        max-width: 1400px;
        margin: 0 auto 40px auto;
      }

      .combined-box {
        background: rgba(30, 30, 45, 0.7);
        backdrop-filter: blur(10px);
        padding: 28px;
        border-radius: 16px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4),
                    0 2px 8px rgba(0, 0, 0, 0.2),
                    inset 0 1px 0 rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 211, 105, 0.3);
        transition: transform 0.2s ease, box-shadow 0.2s ease;
        display: flex;
        gap: 32px;
        flex-wrap: wrap;
      }

      .combined-box:hover {
        transform: translateY(-2px);
        box-shadow: 0 12px 40px rgba(0, 0, 0, 0.5),
                    0 4px 12px rgba(0, 0, 0, 0.3),
                    0 0 0 1px rgba(255, 211, 105, 0.2),
                    inset 0 1px 0 rgba(255, 255, 255, 0.08);
      }

      .config-section {
        flex: 1;
        min-width: 300px;
      }

      .chart-section {
        flex: 1.5;
        min-width: 400px;
      }

      .summary-section {
        flex: 1;
        min-width: 300px;
      }

      .config-section h3 {
        margin-top: 0;
      }

      .chart-section h3,
      .summary-section h3 {
        margin-top: 0;
      }

      #description {
        color: #c8c8c8;
        font-size: 0.9rem;
        line-height: 1.6;
      }

      #totalSummary {
        margin-top: 0;
      }

      /* DESCRIPTION */
      .summary-title {
        background: linear-gradient(135deg, #ffd369 0%, #ffb347 100%);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        margin: 0 0 12px 0;
      }

      #description {
        color: #c8c8c8;
        font-size: 0.95rem;
        line-height: 1.7;
        margin-bottom: 20px;
      }

      #description strong {
        color: #ffd369;
        font-weight: 600;
      }

      /* CHART */
      #chartWrapper {
        margin: 20px 0;
      }

      canvas {
        width: 100%;
        height: 220px;
        background: rgba(15, 15, 25, 0.6);
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.05);
        box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.3);
      }

      /* INPUTS */
      input[type="number"] {
        width: 100%;
        padding: 10px 14px;
        margin: 0 0 4px 0;
        background: rgba(20, 20, 30, 0.8);
        border: 1.5px solid rgba(255, 255, 255, 0.1);
        border-radius: 8px;
        color: #ffd369;
        font-size: 0.95rem;
        font-weight: 500;
        transition: all 0.2s ease;
        box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
      }

      input[type="number"]:hover {
        border-color: rgba(255, 211, 105, 0.3);
        background: rgba(25, 25, 35, 0.9);
      }

      input[type="number"]:focus {
        border-color: #ffd369;
        outline: none;
        background: rgba(30, 30, 40, 0.95);
        box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
      }

      button {
        display: block;
        background: linear-gradient(135deg, #ffd369 0%, #ffb347 100%);
        color: #1a1a2e;
        border: none;
        padding: 16px 32px;
        font-size: 1.15rem;
        font-weight: 600;
        border-radius: 10px;
        cursor: pointer;
        transition: all 0.2s ease;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        letter-spacing: 0.3px;
        margin-top: 20px;
        width: 100%;
      }

      button:hover {
        background: linear-gradient(135deg, #ffdf85 0%, #ffc266 100%);
        transform: translateY(-2px);
        box-shadow: 0 3px 6px rgba(0, 0, 0, 0.25);
      }

      button:active {
        transform: translateY(0);
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
      }

      #scrollHint {
        color: #ffd369;
        margin-top: 12px;
        font-size: 0.9rem;
        font-weight: 500;
        animation: pulse 2s ease-in-out infinite;
      }

      @keyframes pulse {
        0%, 100% { opacity: 0.7; }
        50% { opacity: 1; }
      }

      /* RESULTS */
      #results {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(260px, 1fr));
        gap: 20px;
        max-width: 1400px;
        margin: 0 auto;
      }

      .day-box {
        background: rgba(30, 30, 45, 0.6);
        backdrop-filter: blur(10px);
        padding: 20px;
        border-radius: 14px;
        border: 1px solid rgba(255, 255, 255, 0.08);
        box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3),
                    inset 0 1px 0 rgba(255, 255, 255, 0.05);
        transition: all 0.3s ease;
      }

      .day-box:hover {
        transform: translateY(-4px);
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4),
                    inset 0 1px 0 rgba(255, 255, 255, 0.08);
        border-color: rgba(255, 211, 105, 0.2);
      }

      .day-box h3 {
        background: linear-gradient(135deg, #ffd369 0%, #ffb347 100%);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        margin: 0 0 10px 0;
        font-size: 1.3rem;
      }

      .day-box small {
        color: #999;
        font-size: 0.85rem;
        display: block;
      }

      .day-box p {
        color: #bbb;
        font-size: 0.9rem;
        margin: 8px 0;
      }

      .pearls-grid {
        display: grid;
        row-gap: 12px;
        margin-top: 12px;
      }

      .pearl {
        display: flex;
        align-items: center;
        padding: 8px 12px;
        background: rgba(20, 20, 30, 0.5);
        border-radius: 8px;
        border: 1px solid rgba(255, 255, 255, 0.05);
        transition: all 0.2s ease;
      }

      .pearl {
        cursor: pointer;
      }

      .pearl:hover {
        background: rgba(25, 25, 35, 0.7);
        border-color: rgba(255, 255, 255, 0.1);
        transform: translateX(4px);
      }

      .pearl img {
        width: 36px;
        height: 36px;
        margin-right: 10px;
        filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
      }

      .pearl span {
        display: flex;
        flex-direction: column;
        color: #e0e0e0;
        font-size: 0.95rem;
        font-weight: 500;
      }

      .pearl-name {
        color: #e0e0e0;
        font-size: 0.95rem;
        font-weight: 500;
        margin-bottom: 2px;
      }

      .pearl small {
        display: block;
        color: #aaa;
        font-size: 0.8rem;
        margin-top: 2px;
        font-weight: 400;
        line-height: 1.4;
      }

      #totalSummary {
        margin-top: 20px;
      }

      #totalSummary small {
        color: #888;
        font-style: italic;
      }

      /* PEARL TIMING MODAL */
      .pearl-modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7);
        backdrop-filter: blur(4px);
        z-index: 1000;
        justify-content: center;
        align-items: center;
      }

      .pearl-modal.active {
        display: flex;
      }

      .pearl-modal-content {
        background: rgba(30, 30, 45, 0.95);
        backdrop-filter: blur(10px);
        padding: 28px;
        border-radius: 16px;
        border: 1px solid rgba(255, 211, 105, 0.3);
        box-shadow: 0 12px 40px rgba(0, 0, 0, 0.6);
        max-width: 500px;
        width: 90%;
        max-height: 80vh;
        overflow-y: auto;
        position: relative;
      }

      .pearl-modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
        padding-bottom: 12px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      }

      .pearl-modal-header h3 {
        background: linear-gradient(135deg, #ffd369 0%, #ffb347 100%);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        margin: 0;
        font-size: 1.3rem;
      }

      .pearl-modal-close {
        background: none;
        border: none;
        color: #aaa;
        font-size: 1.5rem;
        cursor: pointer;
        padding: 0;
        width: 32px;
        height: 32px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 6px;
        transition: all 0.2s ease;
      }

      .pearl-modal-close:hover {
        background: rgba(255, 255, 255, 0.1);
        color: #ffd369;
      }

      .pearl-timing-item {
        background: rgba(20, 20, 30, 0.6);
        padding: 12px;
        border-radius: 8px;
        margin-bottom: 10px;
        display: flex;
        align-items: flex-start;
        gap: 12px;
      }

      .pearl-timing-item img {
        width: 36px;
        height: 36px;
        flex-shrink: 0;
        filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
      }

      .pearl-timing-item-content {
        flex: 1;
      }

      .pearl-timing-item strong {
        color: #ffd369;
        display: block;
        margin-bottom: 6px;
      }

      .pearl-timing-item small {
        color: #aaa;
        display: block;
        font-size: 0.85rem;
        line-height: 1.5;
      }

      /* Chart Tooltip */
      .chart-tooltip {
        position: absolute;
        background: rgba(30, 30, 45, 0.95);
        backdrop-filter: blur(10px);
        padding: 12px 16px;
        border-radius: 8px;
        border: 1px solid rgba(255, 211, 105, 0.3);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        pointer-events: none;
        z-index: 1000;
        display: none;
        max-width: 300px;
        font-size: 0.85rem;
        line-height: 1.5;
      }

      .chart-tooltip.active {
        display: block;
      }

      .chart-tooltip strong {
        color: #ffd369;
        display: block;
        margin-bottom: 6px;
      }

      .chart-tooltip small {
        color: #c8c8c8;
        display: block;
        font-size: 0.8rem;
      }

      #chartWrapper {
        position: relative;
        cursor: pointer;
      }
    </style>
  </head>

  <body>
    <h1>Super Animal Royale â€“ Pearl Drop Simulator</h1>

    <div class="top-layout">
      <div class="combined-box">
        <!-- LEFT: Settings -->
        <div class="config-section">
        <h3>Simulation Settings</h3>
          <p style="color: #dddddd; font-size: 14px; line-height: 1.4; margin-bottom: 20px">
          Set the number of clams per day and how many days to simulate. Adjust
          the drop chances for each pearl color to see how your results change.
        </p>

        <label>Clams per day</label>
        <input id="clamsPerDay" type="number" value="150" />

        <label>Days to simulate</label>
        <input id="daysToSim" type="number" value="50" min="1" max="365" />

          <h3 style="margin-top: 24px; margin-bottom: 12px;">Drop Chances</h3>
          <p style="color: #dddddd; font-size: 14px; line-height: 1.4; margin-bottom: 16px">
          Adjust the probability (0-1) for each pearl type to drop from a clam.
          These default values represent the rare drop rates.
        </p>

          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px 16px;">
            <div>
        <label>Black</label>
              <input id="pBlack" type="number" step="0.00001" value="0.0001" />
            </div>
            <div>
        <label>Gold</label>
              <input id="pGold" type="number" step="0.00001" value="0.001" />
            </div>
            <div>
        <label>Purple</label>
              <input id="pPurple" type="number" step="0.00001" value="0.0139" />
            </div>
            <div>
        <label>Blue</label>
              <input id="pBlue" type="number" step="0.00001" value="0.045" />
            </div>
            <div>
        <label>Green</label>
              <input id="pGreen" type="number" step="0.00001" value="0.1" />
            </div>
            <div>
        <label>White</label>
              <input id="pWhite" type="number" step="0.00001" value="0.4" />
            </div>
          </div>

        <button onclick="runSimulation()">Run Simulation</button>
        <div
          id="scrollHint"
          style="color: #ffd369; margin-top: 6px; display: none"
        >
          â¬‡ Scroll down to see results!
        </div>
      </div>

        <!-- MIDDLE: Chart -->
        <div class="chart-section">
          <h3 class="summary-title">Results Chart</h3>
          <p style="color: #c8c8c8; font-size: 0.9rem; line-height: 1.6; margin-bottom: 16px;">
            This chart shows the total number of each pearl type (and empty clams) across all simulated days. 
            The taller the bar, the more drops you received. <strong style="color: #ffd369;">Hover over bars</strong> for details, 
            <strong style="color: #ffd369;">click</strong> to see all drops of that type. Each simulated day represents a 
            <strong>perfect island loop</strong> with <strong>all 41 clams untouched</strong>.             Time calculations are based on 
            <strong>if it takes you 5 minutes to go around the entire island</strong>. Results show idealized outcomes.
          </p>
          <div style="background: rgba(255, 211, 105, 0.1); border-left: 3px solid rgba(255, 211, 105, 0.5); padding: 12px 16px; margin-bottom: 12px; border-radius: 8px;">
            <p style="color: #ddd; font-size: 0.85rem; line-height: 1.6; margin: 0;">
              <strong style="color: #ffd369;">Why I built this:</strong> As a Super Animal Royale player grinding for pearls, I wanted to know what to expect from my farming efforts. The drop rates (especially Black and Gold pearls) are brutal, and it's hard to know if the time investment is worth it without seeing realistic outcomes. This tool helps me plan my pearl farming strategy and set realistic expectations instead of blindly hoping for the best.
            </p>
          </div>
          <div style="background: rgba(255, 211, 105, 0.1); border-left: 3px solid rgba(255, 211, 105, 0.5); padding: 12px 16px; margin-bottom: 16px; border-radius: 8px;">
            <p style="color: #ddd; font-size: 0.85rem; line-height: 1.6; margin: 0;">
              <strong style="color: #ffd369;">Note:</strong> Time calculations help you understand the time investment needed. 
              Remember to take breaks and play at a healthy pace â€“ grinding should be fun, not a chore! ðŸŽ®
            </p>
        </div>
        <div id="chartWrapper">
          <canvas id="chart"></canvas>
          <div id="chartTooltip" class="chart-tooltip"></div>
        </div>
          <div id="totalSummary" style="margin-top: 16px;">
          <small>Run a simulation to populate totals.</small>
          </div>
        </div>
      </div>
    </div>

    <div id="results"></div>

    <!-- Pearl Timing Modal -->
    <div id="pearlModal" class="pearl-modal">
      <div class="pearl-modal-content">
        <div class="pearl-modal-header">
          <h3 id="modalTitle">Pearl Timing Details</h3>
          <button class="pearl-modal-close" onclick="closePearlModal()">&times;</button>
        </div>
        <div id="modalContent"></div>
      </div>
    </div>

    <script>
      const pearlImages = {
        "Black Pearl": "black.png",
        "Gold Pearl": "gold.png",
        "Purple Pearl": "purple.png",
        "Blue Pearl": "blue.png",
        "Green Pearl": "green.png",
        "White Pearl": "white.png",
        "Empty Clam": "empty.png",
      };

      const pearlColors = {
        "Black Pearl": "#333333",
        "Gold Pearl": "#ffd369",
        "Purple Pearl": "#a56cff",
        "Blue Pearl": "#4aa3ff",
        "Green Pearl": "#4aff78",
        "White Pearl": "#e6e6e6",
        "Empty Clam": "#666",
      };

      function getProbabilities() {
        const keys = ["Black", "Gold", "Purple", "Blue", "Green", "White"];
        let p = {},
          sum = 0;
        keys.forEach((k) => {
          p[k] = parseFloat(document.getElementById("p" + k).value);
          sum += p[k];
        });
        p.Empty = 1 - sum;
        return p;
      }

      function rollOneClam() {
        const p = getProbabilities();
        let r = Math.random();

        if (r < p.Black) return "Black Pearl";
        r -= p.Black;
        if (r < p.Gold) return "Gold Pearl";
        r -= p.Gold;
        if (r < p.Purple) return "Purple Pearl";
        r -= p.Purple;
        if (r < p.Blue) return "Blue Pearl";
        r -= p.Blue;
        if (r < p.Green) return "Green Pearl";
        r -= p.Green;
        if (r < p.White) return "White Pearl";
        return "Empty Clam";
      }

      // Helper function to convert hex color to rgba
      function hexToRgba(hex, alpha) {
        // Remove # if present
        hex = hex.replace('#', '');
        
        // Handle 3-digit hex colors
        if (hex.length === 3) {
          hex = hex.split('').map(char => char + char).join('');
        }
        
        // Parse hex to RGB
        const r = parseInt(hex.substring(0, 2), 16);
        const g = parseInt(hex.substring(2, 4), 16);
        const b = parseInt(hex.substring(4, 6), 16);
        
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
      }

      // Store bar positions for interactivity
      let chartBarPositions = [];

      function drawChart(totals, days) {
        try {
        const c = document.getElementById("chart");
          if (!c) {
            console.error("Chart canvas not found");
            return;
          }
          
        const ctx = c.getContext("2d");
          if (!ctx) {
            console.error("Could not get canvas context");
            return;
          }
          
          // Get actual client dimensions
          const displayWidth = Math.max(400, c.clientWidth || 400);
          const displayHeight = Math.max(220, c.clientHeight || 220);
          
          // Reset canvas size to force clear (this also clears the canvas)
          c.width = displayWidth;
          c.height = displayHeight;
          
          // Explicitly clear the canvas (context is still valid after resize)
          ctx.clearRect(0, 0, displayWidth, displayHeight);

          // Always show all pearl types + empty clams in fixed order (rarest to most common)
          const pearlOrder = [
            "Black Pearl",
            "Gold Pearl",
            "Purple Pearl",
            "Blue Pearl",
            "Green Pearl",
            "White Pearl",
            "Empty Clam"
          ];
          
          // Get values for all pearls, defaulting to 0 if not present
          const entries = pearlOrder.map((k) => {
            const value = totals[k] || 0;
            return [k, typeof value === 'number' ? value : 0];
          });
          
          // Calculate max value, but ensure it's at least 1 to avoid division by zero
          const values = entries.map((e) => {
            const val = e[1];
            return (typeof val === 'number' && !isNaN(val) && isFinite(val)) ? val : 0;
          });
          const max = Math.max(1, ...values);
          
          if (!isFinite(max) || max <= 0) {
            console.error("Invalid max value:", max);
            return;
          }
          
          const padding = { top: 40, right: 20, bottom: 50, left: 50 };
          const chartWidth = Math.max(0, displayWidth - padding.left - padding.right);
          const chartHeight = Math.max(0, displayHeight - padding.top - padding.bottom);
          const numBars = pearlOrder.length; // 7 bars (6 pearls + empty clams)
          const barWidth = Math.max(0, (chartWidth / numBars) * 0.7);
          const barSpacing = Math.max(0, chartWidth / numBars);
          
          if (chartWidth <= 0 || chartHeight <= 0 || barWidth <= 0) {
            console.error("Invalid chart dimensions:", { chartWidth, chartHeight, barWidth });
            return;
          }
          
          // Reset bar positions for interactivity
          chartBarPositions = [];
        
        // Draw background
        ctx.fillStyle = "rgba(15, 15, 25, 0.6)";
        ctx.fillRect(0, 0, displayWidth, displayHeight);
        
        // Draw grid lines
        ctx.strokeStyle = "rgba(255, 255, 255, 0.1)";
        ctx.lineWidth = 1;
        const gridLines = 5;
        for (let i = 0; i <= gridLines; i++) {
          const y = padding.top + (chartHeight / gridLines) * i;
          ctx.beginPath();
          ctx.moveTo(padding.left, y);
          ctx.lineTo(displayWidth - padding.right, y);
          ctx.stroke();

          // Y-axis labels
          const value = max - (max / gridLines) * i;
          ctx.fillStyle = "#aaa";
          ctx.font = "11px sans-serif";
          ctx.textAlign = "right";
          ctx.fillText(Math.round(value).toLocaleString(), padding.left - 10, y + 4);
        }

          // Draw bars - always show all bars (6 pearl types + empty clams)
        entries.forEach(([k, v], i) => {
            try {
              const x = padding.left + i * barSpacing + (barSpacing - barWidth) / 2;
              const numValue = typeof v === 'number' && !isNaN(v) ? v : 0;
              let barHeight = (numValue / max) * chartHeight;
              
              // Ensure minimum visible height for all bars (even zero values)
              const minHeight = 4;
              if (barHeight < minHeight && numValue === 0) {
                barHeight = 0; // Truly zero bars have no height
              } else if (barHeight < minHeight && numValue > 0) {
                barHeight = minHeight; // Non-zero bars have minimum visibility
              }
              
              const y = padding.top + chartHeight - barHeight;
              
              // Draw bar with gradient - ensure color exists
              const color = pearlColors[k] || "#888888";
              if (barHeight > 0 && isFinite(barHeight) && isFinite(y)) {
                const gradient = ctx.createLinearGradient(x, y, x, y + barHeight);
                gradient.addColorStop(0, hexToRgba(color, 1.0)); // Full opacity at top
                gradient.addColorStop(1, hexToRgba(color, 0.67)); // ~67% opacity at bottom (aa in hex)
                ctx.fillStyle = gradient;
                ctx.fillRect(x, y, barWidth, barHeight);
                
                // Bar border
                ctx.strokeStyle = color;
          ctx.lineWidth = 2;
                ctx.strokeRect(x, y, barWidth, barHeight);
              } else {
                // Draw a thin line for zero values
                ctx.strokeStyle = hexToRgba(color, 0.25); // ~25% opacity (40 in hex)
                ctx.lineWidth = 1;
          ctx.beginPath();
                ctx.moveTo(x, padding.top + chartHeight);
                ctx.lineTo(x + barWidth, padding.top + chartHeight);
          ctx.stroke();
              }
              
              // Value label on top of bar (always show, even for 0)
              ctx.fillStyle = numValue > 0 ? "#fff" : "#888";
              ctx.font = "bold 12px sans-serif";
              ctx.textAlign = "center";
              const labelY = barHeight > 0 ? y - 8 : padding.top + chartHeight - 8;
              ctx.fillText(
                numValue.toLocaleString(),
                x + barWidth / 2,
                labelY
              );
              
              // X-axis label (pearl name)
              ctx.fillStyle = numValue > 0 ? "#ccc" : "#666";
              ctx.font = "11px sans-serif";
              ctx.textAlign = "center";
              const labelX = x + barWidth / 2;
              const labelYBottom = displayHeight - padding.bottom + 20;
              ctx.save();
              ctx.translate(labelX, labelYBottom);
              ctx.rotate(-Math.PI / 4);
              ctx.fillText(k.replace(" Pearl", ""), 0, 0);
              ctx.restore();
              
              // Store bar position for interactivity (store full bar area including clickable region)
              chartBarPositions.push({
                type: k,
                value: numValue,
                x: x,
                y: padding.top,
                width: barWidth,
                height: chartHeight,
                centerX: x + barWidth / 2
              });
            } catch (err) {
              console.error(`Error drawing bar for ${k}:`, err);
            }
          });
          
          // Draw axis lines
          ctx.strokeStyle = "rgba(255, 255, 255, 0.3)";
          ctx.lineWidth = 2;
          // X-axis
          ctx.beginPath();
          ctx.moveTo(padding.left, padding.top + chartHeight);
          ctx.lineTo(displayWidth - padding.right, padding.top + chartHeight);
          ctx.stroke();
          // Y-axis
          ctx.beginPath();
          ctx.moveTo(padding.left, padding.top);
          ctx.lineTo(padding.left, padding.top + chartHeight);
          ctx.stroke();
          
          // Add mouse event listeners for interactivity (after all drawing is complete)
          setupChartInteractivity(c, totals, days);
        } catch (error) {
          console.error("Error drawing chart:", error);
        }
      }

      function setupChartInteractivity(canvas, totals, days) {
        const tooltip = document.getElementById("chartTooltip");
        if (!tooltip) return;

        // Remove existing listeners if any
        canvas.removeEventListener("mousemove", handleChartMouseMove);
        canvas.removeEventListener("mouseleave", handleChartMouseLeave);
        canvas.removeEventListener("click", handleChartClick);

        // Mouse move handler
        function handleChartMouseMove(event) {
          const rect = canvas.getBoundingClientRect();
          const x = event.clientX - rect.left;
          const y = event.clientY - rect.top;

          // Find which bar is being hovered
          const hoveredBar = chartBarPositions.find(bar => {
            return x >= bar.x && x <= bar.x + bar.width && 
                   y >= bar.y && y <= bar.y + bar.height;
          });

          if (hoveredBar) {
            const totalDrops = Object.values(totals).reduce((a, b) => a + b, 0);
            const percent = totals[hoveredBar.type] && totalDrops > 0
              ? ((totals[hoveredBar.type] / totalDrops) * 100).toFixed(2)
              : "0.00";
            const avgPerDay = days > 0 
              ? (hoveredBar.value / days).toFixed(2)
              : "0.00";
            
            tooltip.innerHTML = `
              <strong>${hoveredBar.type}</strong>
              <small>Total: ${hoveredBar.value.toLocaleString()}</small>
              <small>Percentage: ${percent}%</small>
              <small>Average drops per day: ${avgPerDay}</small>
              <small style="color: #ffd369; margin-top: 4px; font-size: 0.75rem;">Click to see all drops</small>
            `;
            
            tooltip.classList.add("active");
            tooltip.style.left = (event.clientX - rect.left + 15) + "px";
            tooltip.style.top = (event.clientY - rect.top - 10) + "px";
            
            // Keep tooltip within bounds
            if (parseFloat(tooltip.style.left) + tooltip.offsetWidth > canvas.width) {
              tooltip.style.left = (event.clientX - rect.left - tooltip.offsetWidth - 15) + "px";
            }
            if (parseFloat(tooltip.style.top) + tooltip.offsetHeight > canvas.height) {
              tooltip.style.top = (event.clientY - rect.top - tooltip.offsetHeight - 10) + "px";
            }
            
            canvas.style.cursor = "pointer";
          } else {
            tooltip.classList.remove("active");
            canvas.style.cursor = "default";
          }
        }

        // Mouse leave handler
        function handleChartMouseLeave() {
          tooltip.classList.remove("active");
          canvas.style.cursor = "default";
        }

        // Click handler
        function handleChartClick(event) {
          const rect = canvas.getBoundingClientRect();
          const x = event.clientX - rect.left;
          const y = event.clientY - rect.top;

          // Find which bar was clicked
          const clickedBar = chartBarPositions.find(bar => {
            return x >= bar.x && x <= bar.x + bar.width && 
                   y >= bar.y && y <= bar.y + bar.height;
          });

          if (clickedBar) {
            showTotalPearlTiming(clickedBar.type);
          }
        }

        // Add event listeners
        canvas.addEventListener("mousemove", handleChartMouseMove);
        canvas.addEventListener("mouseleave", handleChartMouseLeave);
        canvas.addEventListener("click", handleChartClick);
      }

      function runSimulation() {
        // Get DOM elements
        const resultsEl = document.getElementById("results");
        const totalSummaryEl = document.getElementById("totalSummary");
        const scrollHintEl = document.getElementById("scrollHint");
        
        // Show scroll hint
        if (scrollHintEl) scrollHintEl.style.display = "block";

        // Clear previous results
        if (resultsEl) resultsEl.innerHTML = "";
        if (totalSummaryEl) totalSummaryEl.innerHTML = '<small>Run a simulation to populate totals.</small>';
        
        // Reset totals
        let totals = {};
        Object.keys(pearlImages).forEach((k) => (totals[k] = 0));

        const clams = +clamsPerDay.value;
        let days = +daysToSim.value;
        
        // Validate days: must be between 1 and 365
        if (days < 1) days = 1;
        if (days > 365) days = 365;
        if (daysToSim.value != days) {
          daysToSim.value = days;
        }

        const circles = clams / 41;
        const minutesPerDay = (clams / 41) * 5;

        const pearlOrder = [
          "Empty Clam",
          "White Pearl",
          "Green Pearl",
          "Blue Pearl",
          "Purple Pearl",
          "Gold Pearl",
          "Black Pearl",
        ];

        // Store timing data for each pearl type by day
        const pearlTimingData = {};
        // Store all drops in chronological order for each day
        const dayChronologicalData = {};

        for (let d = 1; d <= days; d++) {
          let day = {};
          // Track when each pearl was obtained this day
          const dayPearlTimings = {};
          // Track all drops in chronological order for this day
          const chronologicalDrops = [];

          for (let i = 0; i < clams; i++) {
            const r = rollOneClam();
            day[r] = (day[r] || 0) + 1;
            totals[r]++;
            
            // Track timing for each pearl drop
            if (!dayPearlTimings[r]) {
              dayPearlTimings[r] = [];
            }
            // Calculate: time from start of this day (not cumulative)
            const timeFromDayStart = ((i + 1) / 41) * 5;
            // Also track cumulative for time since previous calculations
            const totalClamsSoFar = (d - 1) * clams + (i + 1);
            const cumulativeTimeMinutes = (totalClamsSoFar / 41) * 5;
            const dropData = {
              type: r,
              clam: totalClamsSoFar,
              timeMinutes: timeFromDayStart, // Time from start of this day
              cumulativeTimeMinutes: cumulativeTimeMinutes, // For calculating time since previous
              day: d,
              clamInDay: i + 1
            };
            dayPearlTimings[r].push(dropData);
            chronologicalDrops.push(dropData);
          }

          // Store timing data for this day
          pearlTimingData[d] = dayPearlTimings;
          dayChronologicalData[d] = chronologicalDrops;

          // ðŸ”¹ BUILD DAY CARD
          let card = `
      <div class="day-box" data-day="${d}" onclick="showDayTiming(${d})" style="cursor: pointer;">
        <h3>Day ${d}</h3>
        <small>Circles: ${circles.toFixed(2)} | Time: ${minutesPerDay.toFixed(2)} min</small>
        <div class="pearls-grid">
    `;

          for (let k of pearlOrder) {
            if (!day[k]) continue;
            const pearlKey = `day-${d}-${k}`;
            card += `
        <div class="pearl" onclick="event.stopPropagation(); showPearlTiming(${d}, '${k.replace(/'/g, "\\'")}')" data-pearl-type="${k}" data-day="${d}">
          <img src="${pearlImages[k]}">
          <span>${k}: ${day[k]}</span>
        </div>`;
          }

          card += `</div></div>`;
          if (resultsEl) resultsEl.innerHTML += card;
        }

        // Store timing data globally for modal access
        window.pearlTimingData = pearlTimingData;
        window.dayChronologicalData = dayChronologicalData;

        // ðŸ”¹ DRAW CHART (with a small delay to ensure canvas is ready)
        setTimeout(() => {
        drawChart(totals, days);
        }, 50);

        // ðŸ”¹ TOTAL SUMMARY
        let totalClams = clams * days;
        let totalCircles = (clams / 41) * days;
        let totalMinutes = totalCircles * 5;
        let totalHours = (totalMinutes / 60).toFixed(2);

        let totalHTML = `
          <div onclick="showAllDaysTiming()" style="background: rgba(20, 20, 30, 0.6); padding: 16px; border-radius: 8px; margin-top: 16px; cursor: pointer; transition: all 0.2s ease;" onmouseover="this.style.background='rgba(25, 25, 35, 0.7)'" onmouseout="this.style.background='rgba(20, 20, 30, 0.6)'">
            <h4 style="color: #ffd369; margin: 0 0 12px 0; font-size: 1.1rem;">Total Across All Days <small style="color: #aaa; font-size: 0.8rem; font-weight: normal;">(Click to see all drops)</small></h4>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 12px;">
              <div><small style="color: #aaa;">Total circles:</small><br><strong style="color: #ffd369;">${totalCircles.toFixed(2)}</strong></div>
              <div><small style="color: #aaa;">Total time:</small><br><strong style="color: #ffd369;">${totalMinutes.toFixed(2)} min (${totalHours} hours)</strong></div>
              <div><small style="color: #aaa;">Total clams opened:</small><br><strong style="color: #ffd369;">${totalClams.toLocaleString()}</strong></div>
            </div>
          </div>
        `;
        if (totalSummaryEl) totalSummaryEl.innerHTML = totalHTML;
      }

      function showPearlTiming(day, pearlType) {
        const modal = document.getElementById("pearlModal");
        const modalTitle = document.getElementById("modalTitle");
        const modalContent = document.getElementById("modalContent");
        
        if (!modal || !window.pearlTimingData) return;
        
        // Get timing data for this pearl type on this day
        const dayData = window.pearlTimingData[day];
        if (!dayData || !dayData[pearlType] || dayData[pearlType].length === 0) {
          modalContent.innerHTML = "<p style='color: #aaa;'>No timing data available for this pearl type on this day.</p>";
        } else {
          const timings = dayData[pearlType];
          
          modalTitle.textContent = `${pearlType} - Day ${day}`;
          
          let html = `<p style="color: #c8c8c8; margin-bottom: 16px; font-size: 0.9rem;">Found ${timings.length} ${timings.length === 1 ? 'drop' : 'drops'} on Day ${day}:</p>`;
          
            timings.forEach((timing, index) => {
              // Use time from start of day (not cumulative)
              const hours = Math.floor(timing.timeMinutes / 60);
              const minutes = (timing.timeMinutes % 60).toFixed(1);
              const timeDisplay = hours > 0 
                ? `${hours}h ${minutes}min` 
                : `${minutes}min`;
              
              html += `
                <div class="pearl-timing-item">
                  <img src="${pearlImages[pearlType]}" alt="${pearlType}">
                  <div class="pearl-timing-item-content">
                    <strong>Drop #${index + 1}</strong>
                    <small>
                      ${timing.clamInDay}${timing.clamInDay === 1 ? 'st' : timing.clamInDay === 2 ? 'nd' : timing.clamInDay === 3 ? 'rd' : 'th'} clam on Day ${day}<br>
                      Time from start of day: ${timeDisplay}
                    </small>
                  </div>
      </div>
    `;
            });
          
          modalContent.innerHTML = html;
        }
        
        modal.classList.add("active");
      }

      function showDayTiming(day) {
        const modal = document.getElementById("pearlModal");
        const modalTitle = document.getElementById("modalTitle");
        const modalContent = document.getElementById("modalContent");
        
        if (!modal || !window.dayChronologicalData) return;
        
        // Get chronological data for this day
        const dayData = window.dayChronologicalData[day];
        if (!dayData || dayData.length === 0) {
          modalContent.innerHTML = "<p style='color: #aaa;'>No data available for this day.</p>";
        } else {
          modalTitle.textContent = `Day ${day} - All Drops`;
          
          let html = `<p style="color: #c8c8c8; margin-bottom: 16px; font-size: 0.9rem;">${dayData.length} drops on Day ${day} in chronological order:</p>`;
          
          dayData.forEach((drop, index) => {
            const hours = Math.floor(drop.timeMinutes / 60);
            const minutes = (drop.timeMinutes % 60).toFixed(1);
            const timeDisplay = hours > 0 
              ? `${hours}h ${minutes}min` 
              : `${minutes}min`;
            
            html += `
              <div class="pearl-timing-item">
                <img src="${pearlImages[drop.type]}" alt="${drop.type}">
                <div class="pearl-timing-item-content">
                  <strong>#${index + 1} - ${drop.type}</strong>
                  <small>
                    ${drop.clamInDay}${drop.clamInDay === 1 ? 'st' : drop.clamInDay === 2 ? 'nd' : drop.clamInDay === 3 ? 'rd' : 'th'} clam on Day ${day}<br>
                    Time from start of day: ${timeDisplay}
                  </small>
                </div>
              </div>
            `;
          });
          
          modalContent.innerHTML = html;
        }
        
        modal.classList.add("active");
      }

      function showTotalPearlTiming(pearlType) {
        const modal = document.getElementById("pearlModal");
        const modalTitle = document.getElementById("modalTitle");
        const modalContent = document.getElementById("modalContent");
        
        if (!modal || !window.pearlTimingData) return;
        
        // Collect all drops of this pearl type across all days
        const allDrops = [];
        Object.keys(window.pearlTimingData).forEach(day => {
          const dayData = window.pearlTimingData[day];
          if (dayData[pearlType]) {
            dayData[pearlType].forEach(drop => {
              allDrops.push({
                ...drop,
                day: parseInt(day)
              });
            });
          }
        });
        
        // Sort by cumulative time to get chronological order
        allDrops.sort((a, b) => a.cumulativeTimeMinutes - b.cumulativeTimeMinutes);
        
        if (allDrops.length === 0) {
          modalContent.innerHTML = "<p style='color: #aaa;'>No drops found for this pearl type.</p>";
        } else {
          modalTitle.textContent = `${pearlType} - All Days (${allDrops.length} total)`;
          
          let html = `<p style="color: #c8c8c8; margin-bottom: 16px; font-size: 0.9rem;">Found ${allDrops.length} ${allDrops.length === 1 ? 'drop' : 'drops'} across all ${Object.keys(window.pearlTimingData).length} days:</p>`;
          
          allDrops.forEach((drop, index) => {
            const hours = Math.floor(drop.timeMinutes / 60);
            const minutes = (drop.timeMinutes % 60).toFixed(1);
            const timeDisplay = hours > 0 
              ? `${hours}h ${minutes}min` 
              : `${minutes}min`;
            
            html += `
              <div class="pearl-timing-item">
                <img src="${pearlImages[pearlType]}" alt="${pearlType}">
                <div class="pearl-timing-item-content">
                  <strong>#${index + 1} - Day ${drop.day}</strong>
                  <small>
                    ${drop.clamInDay}${drop.clamInDay === 1 ? 'st' : drop.clamInDay === 2 ? 'nd' : drop.clamInDay === 3 ? 'rd' : 'th'} clam on Day ${drop.day}<br>
                    Time from start of day: ${timeDisplay}
                  </small>
                </div>
              </div>
            `;
          });
          
          modalContent.innerHTML = html;
        }
        
        modal.classList.add("active");
      }

      function showAllDaysTiming() {
        const modal = document.getElementById("pearlModal");
        const modalTitle = document.getElementById("modalTitle");
        const modalContent = document.getElementById("modalContent");
        
        if (!modal || !window.dayChronologicalData) return;
        
        // Collect all drops across all days in chronological order
        const allDrops = [];
        Object.keys(window.dayChronologicalData).forEach(day => {
          const dayData = window.dayChronologicalData[day];
          dayData.forEach(drop => {
            allDrops.push({
              ...drop,
              day: parseInt(day)
            });
          });
        });
        
        // Sort by cumulative time to get chronological order across all days
        allDrops.sort((a, b) => a.cumulativeTimeMinutes - b.cumulativeTimeMinutes);
        
        if (allDrops.length === 0) {
          modalContent.innerHTML = "<p style='color: #aaa;'>No data available.</p>";
        } else {
          const totalDays = Object.keys(window.dayChronologicalData).length;
          modalTitle.textContent = `All Days - All Drops`;
          
          let html = `<p style="color: #c8c8c8; margin-bottom: 16px; font-size: 0.9rem;">${allDrops.length} drops across all ${totalDays} days in chronological order:</p>`;
          
          allDrops.forEach((drop, index) => {
            const hours = Math.floor(drop.timeMinutes / 60);
            const minutes = (drop.timeMinutes % 60).toFixed(1);
            const timeDisplay = hours > 0 
              ? `${hours}h ${minutes}min` 
              : `${minutes}min`;
            
            html += `
              <div class="pearl-timing-item">
                <img src="${pearlImages[drop.type]}" alt="${drop.type}">
                <div class="pearl-timing-item-content">
                  <strong>#${index + 1} - ${drop.type} (Day ${drop.day})</strong>
                  <small>
                    ${drop.clamInDay}${drop.clamInDay === 1 ? 'st' : drop.clamInDay === 2 ? 'nd' : drop.clamInDay === 3 ? 'rd' : 'th'} clam on Day ${drop.day}<br>
                    Time from start of day: ${timeDisplay}
                  </small>
                </div>
              </div>
            `;
          });
          
          modalContent.innerHTML = html;
        }
        
        modal.classList.add("active");
      }

      function closePearlModal() {
        const modal = document.getElementById("pearlModal");
        if (modal) {
          modal.classList.remove("active");
        }
      }

      // Close modal when clicking outside
      document.addEventListener("click", function(event) {
        const modal = document.getElementById("pearlModal");
        if (modal && event.target === modal) {
          closePearlModal();
        }
      });

      // Close modal with Escape key
      document.addEventListener("keydown", function(event) {
        if (event.key === "Escape") {
          closePearlModal();
        }
      });
    </script>
  </body>
</html>
