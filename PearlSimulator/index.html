<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/x-icon" href="favicon.ico" />
    <title>SAR Pearl Drop Simulator</title>

    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        background: #1a1a2e;
        color: #e8e8e8;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', sans-serif;
        padding: 40px 20px;
        min-height: 100vh;
        line-height: 1.6;
      }

      h1 {
        background: linear-gradient(135deg, #ffd369 0%, #ffb347 50%, #ffd369 100%);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        text-align: center;
        font-size: 2.5rem;
        font-weight: 700;
        margin-bottom: 40px;
        letter-spacing: -0.5px;
      }

      h3 {
        font-size: 1.25rem;
        font-weight: 600;
        margin-bottom: 16px;
        letter-spacing: 0.3px;
      }

      label {
        display: block;
        color: #b8b8b8;
        font-size: 0.9rem;
        font-weight: 500;
        margin-top: 12px;
        margin-bottom: 2px;
        letter-spacing: 0.2px;
      }

      label:first-of-type {
        margin-top: 16px;
      }

      .config-box p {
        margin-bottom: 20px;
      }

      br {
        line-height: 0;
        margin: 0;
        padding: 0;
      }

      /* TOP LAYOUT */
      .top-layout {
        max-width: 1400px;
        margin: 0 auto 40px auto;
      }

      .combined-box {
        background: rgba(30, 30, 45, 0.7);
        padding: 28px;
        border-radius: 16px;
        border: 1px solid rgba(255, 211, 105, 0.3);
        transition: transform 0.2s ease;
        display: flex;
        gap: 32px;
        flex-wrap: wrap;
      }

      .combined-box:hover {
        transform: translateY(-2px);
      }

      .config-section {
        flex: 1;
        min-width: 300px;
      }

      .chart-section {
        flex: 1.5;
        min-width: 400px;
      }

      .summary-section {
        flex: 1;
        min-width: 300px;
      }

      .day-filter-dropdown {
        margin-bottom: 16px;
      }

      .day-filter-dropdown select {
        width: 100%;
        max-width: 300px;
        padding: 10px 14px;
        background: rgba(30, 30, 45, 0.8);
        border: 1px solid rgba(255, 211, 105, 0.3);
        border-radius: 8px;
        color: #ddd;
        font-size: 0.95rem;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .day-filter-dropdown select:hover {
        border-color: rgba(255, 211, 105, 0.5);
        background: rgba(35, 35, 50, 0.9);
      }

      .day-filter-dropdown select:focus {
        outline: none;
        border-color: rgba(255, 211, 105, 0.7);
        background: rgba(40, 40, 55, 0.95);
      }

      .config-section h3 {
        margin-top: 0;
      }

      .chart-section h3,
      .summary-section h3 {
        margin-top: 0;
      }

      #description {
        color: #c8c8c8;
        font-size: 0.9rem;
        line-height: 1.6;
      }

      #totalSummary {
        margin-top: 0;
      }

      /* DESCRIPTION */
      .summary-title {
        background: linear-gradient(135deg, #ffd369 0%, #ffb347 100%);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        margin: 0 0 12px 0;
      }

      #description {
        color: #c8c8c8;
        font-size: 0.95rem;
        line-height: 1.7;
        margin-bottom: 20px;
      }

      #description strong {
        color: #ffd369;
        font-weight: 600;
      }

      /* CHART */
      #chartWrapper {
        margin: 20px 0;
      }

      canvas {
        width: 100%;
        height: 220px;
        background: rgba(15, 15, 25, 0.6);
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.05);
      }

      /* INPUTS */
      input[type="number"] {
        width: 100%;
        padding: 10px 14px;
        margin: 0 0 4px 0;
        background: rgba(20, 20, 30, 0.8);
        border: 1.5px solid rgba(255, 255, 255, 0.1);
        border-radius: 8px;
        color: #ffd369;
        font-size: 0.95rem;
        font-weight: 500;
        transition: all 0.2s ease;
      }

      input[type="number"]:hover {
        border-color: rgba(255, 211, 105, 0.3);
        background: rgba(25, 25, 35, 0.9);
      }

      input[type="number"]:focus {
        border-color: #ffd369;
        outline: none;
        background: rgba(30, 30, 40, 0.95);
      }

      button {
        display: block;
        background: linear-gradient(135deg, #ffd369 0%, #ffb347 100%);
        color: #1a1a2e;
        border: none;
        padding: 16px 32px;
        font-size: 1.15rem;
        font-weight: 600;
        border-radius: 10px;
        cursor: pointer;
        transition: all 0.2s ease;
        letter-spacing: 0.3px;
        margin-top: 20px;
        width: 100%;
      }

      button:hover {
        background: linear-gradient(135deg, #ffdf85 0%, #ffc266 100%);
        transform: translateY(-2px);
      }

      button:active {
        transform: translateY(0);
      }

      #scrollHint {
        color: #ffd369;
        margin-top: 12px;
        font-size: 0.9rem;
        font-weight: 500;
        animation: pulse 2s ease-in-out infinite;
      }

      @keyframes pulse {
        0%, 100% { opacity: 0.7; }
        50% { opacity: 1; }
      }

      /* RESULTS */
      #results {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(260px, 1fr));
        gap: 20px;
        max-width: 1400px;
        margin: 0 auto;
      }

      .day-box {
        background: rgba(30, 30, 45, 0.6);
        padding: 20px;
        border-radius: 14px;
        border: 1px solid rgba(255, 255, 255, 0.08);
        transition: all 0.3s ease;
      }

      .day-box:hover {
        transform: translateY(-4px);
        border-color: rgba(255, 211, 105, 0.2);
      }

      .day-box h3 {
        background: linear-gradient(135deg, #ffd369 0%, #ffb347 100%);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        margin: 0 0 10px 0;
        font-size: 1.3rem;
      }

      .day-box small {
        color: #999;
        font-size: 0.85rem;
        display: block;
      }

      .day-box p {
        color: #bbb;
        font-size: 0.9rem;
        margin: 8px 0;
      }

      .pearls-grid {
        display: grid;
        row-gap: 12px;
        margin-top: 12px;
      }

      .pearl {
        display: flex;
        align-items: center;
        padding: 8px 12px;
        background: rgba(20, 20, 30, 0.5);
        border-radius: 8px;
        border: 1px solid rgba(255, 255, 255, 0.05);
        transition: all 0.2s ease;
      }

      .pearl {
        cursor: pointer;
      }

      .pearl:hover {
        background: rgba(25, 25, 35, 0.7);
        border-color: rgba(255, 255, 255, 0.1);
        transform: translateX(4px);
      }

      .pearl img {
        width: 36px;
        height: 36px;
        margin-right: 10px;
        filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
      }

      .pearl span {
        display: flex;
        flex-direction: column;
        color: #e0e0e0;
        font-size: 0.95rem;
        font-weight: 500;
      }

      .pearl-name {
        color: #e0e0e0;
        font-size: 0.95rem;
        font-weight: 500;
        margin-bottom: 2px;
      }

      .pearl small {
        display: block;
        color: #aaa;
        font-size: 0.8rem;
        margin-top: 2px;
        font-weight: 400;
        line-height: 1.4;
      }

      #totalSummary {
        margin-top: 20px;
      }

      #totalSummary small {
        color: #888;
        font-style: italic;
      }

      /* PEARL TIMING MODAL */
      .pearl-modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7);
        z-index: 1000;
        justify-content: center;
        align-items: center;
      }

      .pearl-modal.active {
        display: flex;
      }

      .pearl-modal-content {
        background: rgba(30, 30, 45, 0.95);
        padding: 28px;
        border-radius: 16px;
        border: 1px solid rgba(255, 211, 105, 0.3);
        max-width: 500px;
        width: 90%;
        max-height: 80vh;
        display: flex;
        flex-direction: column;
        position: relative;
      }

      .pearl-modal-header {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        margin-bottom: 20px;
        padding-bottom: 12px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        flex-shrink: 0;
      }

      .pearl-modal-header-text {
        flex: 1;
      }

      .pearl-modal-description {
        color: #c8c8c8;
        margin: 8px 0 0 0;
        font-size: 0.9rem;
      }

      #modalContent {
        overflow-y: auto;
        flex: 1;
        min-height: 0;
        padding-right: 12px;
      }

      .pearl-modal-header h3 {
        background: linear-gradient(135deg, #ffd369 0%, #ffb347 100%);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        margin: 0;
        font-size: 1.3rem;
      }

      .pearl-modal-close {
        background: none;
        border: none;
        color: #aaa;
        font-size: 1.5rem;
        cursor: pointer;
        padding: 0;
        width: 32px;
        height: 32px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 6px;
        transition: all 0.2s ease;
        box-shadow: none;
        text-shadow: none;
      }

      .pearl-modal-close:hover {
        background: rgba(255, 255, 255, 0.1);
        color: #ffd369;
      }

      .pearl-timing-item {
        background: rgba(20, 20, 30, 0.6);
        padding: 12px;
        border-radius: 8px;
        margin-bottom: 10px;
        display: flex;
        align-items: flex-start;
        gap: 12px;
      }

      .pearl-timing-item img {
        width: 36px;
        height: 36px;
        flex-shrink: 0;
        filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
      }

      .pearl-timing-item-content {
        flex: 1;
      }

      .pearl-timing-item strong {
        color: #ffd369;
        display: block;
        margin-bottom: 6px;
      }

      .pearl-timing-item small {
        color: #aaa;
        display: block;
        font-size: 0.85rem;
        line-height: 1.5;
      }

      /* Chart Tooltip */
      .chart-tooltip {
        position: absolute;
        background: rgba(30, 30, 45, 0.95);
        padding: 12px 16px;
        border-radius: 8px;
        border: 1px solid rgba(255, 211, 105, 0.3);
        pointer-events: none;
        z-index: 1000;
        display: none;
        max-width: 300px;
        font-size: 0.85rem;
        line-height: 1.5;
      }

      .chart-tooltip.active {
        display: block;
      }

      .chart-tooltip strong {
        color: #ffd369;
        display: block;
        margin-bottom: 6px;
      }

      .chart-tooltip small {
        color: #c8c8c8;
        display: block;
        font-size: 0.8rem;
      }

      #chartWrapper {
        position: relative;
        cursor: pointer;
      }

      /* Collapsible Section */
      .collapsible-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        cursor: pointer;
        padding: 12px 0;
        user-select: none;
        transition: color 0.2s ease;
      }

      .collapsible-header:hover {
        color: #ffd369;
      }

      .collapsible-header h3 {
        margin: 0;
      }

      .collapsible-toggle {
        font-size: 1.2rem;
        color: #ffd369;
        transition: transform 0.3s ease;
        font-weight: bold;
        transform: rotate(180deg);
      }

      .collapsible-toggle.collapsed {
        transform: rotate(0deg);
      }

      .collapsible-content {
        max-height: 1000px;
        overflow: hidden;
        transition: max-height 0.3s ease, opacity 0.3s ease;
        opacity: 1;
      }

      .collapsible-content.collapsed {
        max-height: 0;
        opacity: 0;
        padding-top: 0;
        padding-bottom: 0;
        margin: 0;
      }

      /* Info Tooltip */
      .info-icon {
        position: relative;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        margin-left: 8px;
        cursor: help;
        width: 18px;
        height: 18px;
        border-radius: 50%;
        border: 2px solid #ffd369;
        color: #ffd369;
        font-size: 0.75rem;
        font-weight: bold;
        font-family: Arial, sans-serif;
        line-height: 1;
        vertical-align: middle;
      }

      .info-icon:hover::after {
        content: "Each day = perfect island loop with all 41 clams untouched. Time calculations based on 5 minutes per complete loop. Results show idealized outcomes.";
        position: absolute;
        bottom: calc(100% + 10px);
        left: 50%;
        transform: translateX(-50%);
        background: rgba(30, 30, 45, 0.98);
        padding: 12px 16px;
        border-radius: 8px;
        border: 1px solid rgba(255, 211, 105, 0.3);
        color: #ddd;
        font-size: 0.8rem;
        line-height: 1.5;
        white-space: normal;
        width: 280px;
        z-index: 1000;
        pointer-events: none;
        font-weight: normal;
        text-align: left;
      }

      .info-icon:hover::before {
        content: "";
        position: absolute;
        bottom: calc(100% + 4px);
        left: 50%;
        transform: translateX(-50%);
        border: 6px solid transparent;
        border-bottom-color: rgba(255, 211, 105, 0.3);
        z-index: 1001;
        pointer-events: none;
      }

      /* Day and Pearl Tooltips */
      .day-box[data-tooltip],
      .pearl[data-tooltip] {
        position: relative;
      }

      .day-box[data-tooltip]:hover::after {
        content: attr(data-tooltip);
        position: absolute;
        bottom: calc(100% + 10px);
        left: 50%;
        transform: translateX(-50%);
        background: rgba(30, 30, 45, 0.98);
        padding: 12px 16px;
        border-radius: 8px;
        border: 1px solid rgba(255, 211, 105, 0.3);
        color: #ddd;
        font-size: 0.85rem;
        line-height: 1.6;
        white-space: normal;
        max-width: 320px;
        min-width: 200px;
        z-index: 1000;
        pointer-events: none;
        font-weight: normal;
        text-align: left;
      }

      .pearl[data-tooltip]:hover::after {
        content: attr(data-tooltip);
        position: absolute;
        bottom: calc(100% + 10px);
        left: 50%;
        transform: translateX(-50%);
        background: rgba(30, 30, 45, 0.98);
        padding: 12px 16px;
        border-radius: 8px;
        border: 1px solid rgba(255, 211, 105, 0.3);
        color: #ddd;
        font-size: 0.85rem;
        line-height: 1.6;
        white-space: normal;
        max-width: 320px;
        min-width: 200px;
        z-index: 1002;
        pointer-events: none;
        font-weight: normal;
        text-align: left;
      }

      .day-box[data-tooltip]:hover::before {
        content: "";
        position: absolute;
        bottom: calc(100% + 4px);
        left: 50%;
        transform: translateX(-50%);
        border: 6px solid transparent;
        border-bottom-color: rgba(255, 211, 105, 0.3);
        z-index: 1001;
        pointer-events: none;
      }

      .pearl[data-tooltip]:hover::before {
        content: "";
        position: absolute;
        bottom: calc(100% + 4px);
        left: 50%;
        transform: translateX(-50%);
        border: 6px solid transparent;
        border-bottom-color: rgba(255, 211, 105, 0.3);
        z-index: 1003;
        pointer-events: none;
      }

      /* Hide day-box tooltip when pearl is hovered */
      .day-box.pearl-hovered::after,
      .day-box.pearl-hovered::before {
        display: none !important;
      }

      /* Loading Animation */
      .loading-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 60px 20px;
        color: #ffd369;
      }

      .loading-spinner {
        width: 50px;
        height: 50px;
        border: 4px solid rgba(255, 211, 105, 0.2);
        border-top: 4px solid #ffd369;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin-bottom: 20px;
      }

      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }

      .loading-text {
        font-size: 1rem;
        color: #ddd;
        margin-top: 10px;
      }

      /* Filter Styles */
      .pearl-filter-item {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 8px;
        background: rgba(30, 30, 45, 0.5);
        border-radius: 6px;
        cursor: pointer;
        transition: background 0.2s;
        user-select: none;
      }

      .pearl-filter-item:hover {
        background: rgba(40, 40, 55, 0.7);
      }

      .pearl-filter-item input[type="checkbox"] {
        width: 18px;
        height: 18px;
        cursor: pointer;
        accent-color: #ffd369;
        pointer-events: auto;
        flex-shrink: 0;
      }

      .pearl-filter-item label {
        cursor: pointer;
        color: #ddd;
        font-size: 0.9rem;
        flex: 1;
        display: flex;
        align-items: center;
        gap: 6px;
        margin: 0;
      }

      .pearl-filter-item img {
        width: 20px;
        height: 20px;
      }

      #daySearch:focus {
        outline: none;
        border-color: rgba(255, 211, 105, 0.6);
      }

      #searchFilterContent {
        transition: max-height 0.3s ease-out, opacity 0.3s ease-out;
      }

      #searchFilterToggle {
        user-select: none;
        transform: rotate(0deg);
      }

      #searchFilterToggle.rotated {
        transform: rotate(180deg);
      }

      /* Scroll to Top Button */
      #scrollToTop {
        position: fixed;
        bottom: 30px;
        right: 30px;
        width: 50px;
        height: 50px;
        background: rgba(255, 211, 105, 0.9);
        border: 2px solid rgba(255, 211, 105, 0.5);
        border-radius: 50%;
        cursor: pointer;
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 999;
        transition: all 0.3s ease;
        padding: 0;
        margin: 0;
      }

      #scrollToTop:hover {
        background: rgba(255, 211, 105, 1);
        transform: translateY(-3px);
      }

      #scrollToTop.active {
        display: flex;
      }

      #scrollToTop::before {
        content: '';
        width: 0;
        height: 0;
        border-left: 8px solid transparent;
        border-right: 8px solid transparent;
        border-bottom: 12px solid #1a1a2e;
        margin-top: -4px;
      }
    </style>
  </head>

  <body>
    <h1>Super Animal Royale â€“ Pearl Drop Simulator</h1>

    <div style="max-width: 1400px; margin: 0 auto 20px auto;">
      <div style="background: rgba(255, 211, 105, 0.1); border-left: 3px solid rgba(255, 211, 105, 0.5); padding: 12px 16px; margin-bottom: 12px; border-radius: 8px;">
        <p style="color: #ddd; font-size: 0.85rem; line-height: 1.6; margin: 0;">
          <strong style="color: #ffd369;">Why I built this:</strong> As a Super Animal Royale player grinding for pearls, I wanted to know what to expect from my farming efforts. The drop rates (especially Black and Gold pearls) are brutal, and it's hard to know if the time investment is worth it without seeing realistic outcomes. This tool helps me plan my pearl farming strategy and set realistic expectations instead of blindly hoping for the best.
        </p>
      </div>
      <div style="background: rgba(255, 80, 80, 0.15); border-left: 3px solid rgba(255, 100, 100, 0.8); padding: 12px 16px; margin-bottom: 20px; border-radius: 8px;">
        <p style="color: #ddd; font-size: 0.85rem; line-height: 1.6; margin: 0;">
          <strong style="color: #ff6b6b;">Note:</strong> Time calculations help you understand the time investment needed. 
          Remember to take breaks and play at a healthy pace â€“ grinding should be fun, not a chore! ðŸŽ®
        </p>
      </div>
    </div>

    <div class="top-layout">
      <div class="combined-box">
        <!-- LEFT: Settings -->
        <div class="config-section">
        <h3>Simulation Settings</h3>
          <p style="color: #dddddd; font-size: 14px; line-height: 1.4; margin-bottom: 20px">
          Set the number of clams per day and how many days to simulate. Adjust
          the drop chances for each pearl color to see how your results change.
        </p>

        <label>Clams per day</label>
        <input id="clamsPerDay" type="number" value="150" />

        <label>Days to simulate</label>
        <input id="daysToSim" type="number" value="50" min="1" max="365" />

        <div style="margin-top: 24px;">
          <div class="collapsible-header" onclick="toggleDropChances()">
            <h3 style="margin: 0;">Drop Chances (Optional)</h3>
            <span id="dropChancesToggle" class="collapsible-toggle collapsed">â–¼</span>
          </div>
          <div id="dropChancesContent" class="collapsible-content collapsed">
            <p style="color: #dddddd; font-size: 14px; line-height: 1.4; margin-bottom: 16px; margin-top: 12px;">
          Adjust the probability (0-1) for each pearl type to drop from a clam.
          These default values represent the rare drop rates.
        </p>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px 16px;">
              <div>
        <label>Black</label>
                <input id="pBlack" type="number" step="0.00001" value="0.0001" />
              </div>
              <div>
        <label>Gold</label>
                <input id="pGold" type="number" step="0.00001" value="0.001" />
              </div>
              <div>
        <label>Purple</label>
                <input id="pPurple" type="number" step="0.00001" value="0.0139" />
              </div>
              <div>
        <label>Blue</label>
                <input id="pBlue" type="number" step="0.00001" value="0.045" />
              </div>
              <div>
        <label>Green</label>
                <input id="pGreen" type="number" step="0.00001" value="0.1" />
              </div>
              <div>
        <label>White</label>
                <input id="pWhite" type="number" step="0.00001" value="0.4" />
              </div>
            </div>
          </div>
        </div>

        <button id="simulateButton" onclick="runSimulation()">Run Simulation</button>
        <div
          id="scrollHint"
          style="color: #ffd369; margin-top: 6px; display: none"
        >
          â¬‡ Scroll down to see results!
        </div>
      </div>

        <!-- MIDDLE: Chart -->
        <div class="chart-section">
          <h3 class="summary-title">Results Chart</h3>
          <div id="dayFilterDropdown" class="day-filter-dropdown" style="display: none;">
            <select id="dayFilterSelect">
              <!-- Options will be populated by JavaScript -->
            </select>
        </div>
          <p style="color: #c8c8c8; font-size: 0.9rem; line-height: 1.6; margin-bottom: 16px;">
            <strong style="color: #ffd369;">Hover</strong> over bars for details, <strong style="color: #ffd369;">click</strong> to see all drops of that type.
            <span class="info-icon">i</span>
          </p>
          <div id="totalSummary" style="margin-bottom: 16px;">
            <small>Run a simulation to populate totals.</small>
        </div>
        <div id="chartWrapper">
          <canvas id="chart"></canvas>
          <div id="chartTooltip" class="chart-tooltip"></div>
        </div>
        </div>
      </div>
        </div>

    <!-- Search and Filter Section -->
    <div id="searchFilterSection" style="display: none; margin: 20px auto; max-width: 1400px; background: rgba(20, 20, 30, 0.6); border-radius: 12px; border: 1px solid rgba(255, 211, 105, 0.2); overflow: hidden;">
      <div id="searchFilterHeader" onclick="toggleSearchFilter()" style="padding: 12px 16px; cursor: pointer; display: flex; justify-content: space-between; align-items: center; background: rgba(30, 30, 45, 0.5); transition: background 0.2s;" onmouseover="this.style.background='rgba(35, 35, 50, 0.6)'" onmouseout="this.style.background='rgba(30, 30, 45, 0.5)'">
        <h3 style="color: #ffd369; margin: 0; font-size: 1rem; font-weight: normal;">Search & Filter Results</h3>
        <span id="searchFilterToggle" style="color: #ffd369; font-size: 1.2rem; transition: transform 0.2s;">â–¼</span>
        </div>
      
      <div id="searchFilterContent" style="display: none; padding: 16px;">
        <!-- Search Bar -->
        <div style="margin-bottom: 16px;">
          <label for="daySearch" style="display: block; color: #ddd; margin-bottom: 8px; font-size: 0.9rem;">Search Days:</label>
          <input 
            type="text" 
            id="daySearch" 
            placeholder="Search by day number or pearl type..."
            style="width: 100%; padding: 10px 14px; background: rgba(30, 30, 45, 0.8); border: 1px solid rgba(255, 211, 105, 0.3); border-radius: 8px; color: #ddd; font-size: 0.95rem;"
          />
        </div>

        <!-- Pearl Type Filters -->
        <div style="margin-bottom: 8px;">
          <label style="display: block; color: #ddd; margin-bottom: 8px; font-size: 0.9rem;">Filter by Pearl/Clam Type:</label>
          <div id="pearlFilters" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 10px;">
            <!-- Filters will be populated by JavaScript -->
          </div>
        </div>
        
        <div id="filterResults" style="margin-top: 12px; color: #aaa; font-size: 0.85rem;"></div>
      </div>
    </div>

    <div id="results"></div>

    <!-- Pearl Timing Modal -->
    <div id="pearlModal" class="pearl-modal">
      <div class="pearl-modal-content">
        <div class="pearl-modal-header">
          <div class="pearl-modal-header-text">
            <h3 id="modalTitle">Pearl Timing Details</h3>
            <p id="modalDescription" class="pearl-modal-description"></p>
          </div>
          <button class="pearl-modal-close" onclick="closePearlModal()">&times;</button>
        </div>
        <div id="modalContent"></div>
      </div>
    </div>

    <!-- Scroll to Top Button -->
    <button id="scrollToTop" aria-label="Scroll to top"></button>

    <script>
      const pearlImages = {
        "Black Pearl": "black.png",
        "Gold Pearl": "gold.png",
        "Purple Pearl": "purple.png",
        "Blue Pearl": "blue.png",
        "Green Pearl": "green.png",
        "White Pearl": "white.png",
        "Empty Clam": "empty.png",
      };

      const pearlColors = {
        "Black Pearl": "#333333",
        "Gold Pearl": "#ffd369",
        "Purple Pearl": "#a56cff",
        "Blue Pearl": "#4aa3ff",
        "Green Pearl": "#4aff78",
        "White Pearl": "#e6e6e6",
        "Empty Clam": "#666",
      };

      function getProbabilities() {
        const keys = ["Black", "Gold", "Purple", "Blue", "Green", "White"];
        let p = {},
          sum = 0;
        keys.forEach((k) => {
          p[k] = parseFloat(document.getElementById("p" + k).value);
          sum += p[k];
        });
        p.Empty = 1 - sum;
        return p;
      }

      function toggleDropChances() {
        const content = document.getElementById("dropChancesContent");
        const toggle = document.getElementById("dropChancesToggle");
        
        if (content && toggle) {
          content.classList.toggle("collapsed");
          toggle.classList.toggle("collapsed");
        }
      }

      function rollOneClam() {
        const p = getProbabilities();
        let r = Math.random();

        if (r < p.Black) return "Black Pearl";
        r -= p.Black;
        if (r < p.Gold) return "Gold Pearl";
        r -= p.Gold;
        if (r < p.Purple) return "Purple Pearl";
        r -= p.Purple;
        if (r < p.Blue) return "Blue Pearl";
        r -= p.Blue;
        if (r < p.Green) return "Green Pearl";
        r -= p.Green;
        if (r < p.White) return "White Pearl";
        return "Empty Clam";
      }

      // Helper function to convert hex color to rgba
      function hexToRgba(hex, alpha) {
        // Remove # if present
        hex = hex.replace('#', '');
        
        // Handle 3-digit hex colors
        if (hex.length === 3) {
          hex = hex.split('').map(char => char + char).join('');
        }
        
        // Parse hex to RGB
        const r = parseInt(hex.substring(0, 2), 16);
        const g = parseInt(hex.substring(2, 4), 16);
        const b = parseInt(hex.substring(4, 6), 16);
        
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
      }

      // Store bar positions for interactivity
      let chartBarPositions = [];

      function drawChart(totals, days, selectedDay = null) {
        try {
        const c = document.getElementById("chart");
          if (!c) {
            console.error("Chart canvas not found");
            return;
          }
          
        const ctx = c.getContext("2d");
          if (!ctx) {
            console.error("Could not get canvas context");
            return;
          }
          
          // Get actual client dimensions
          const displayWidth = Math.max(400, c.clientWidth || 400);
          const displayHeight = Math.max(220, c.clientHeight || 220);
          
          // Reset canvas size to force clear (this also clears the canvas)
          c.width = displayWidth;
          c.height = displayHeight;
          
          // Explicitly clear the canvas (context is still valid after resize)
          ctx.clearRect(0, 0, displayWidth, displayHeight);

          // Always show all pearl types + empty clams in fixed order (rarest to most common)
          const pearlOrder = [
            "Black Pearl",
            "Gold Pearl",
            "Purple Pearl",
            "Blue Pearl",
            "Green Pearl",
            "White Pearl",
            "Empty Clam"
          ];
          
          // Use selected day totals if provided, otherwise use all days totals
          const dataToUse = selectedDay && window.dayTotals && window.dayTotals[selectedDay] 
            ? window.dayTotals[selectedDay] 
            : totals;
          
          // Get values for all pearls, defaulting to 0 if not present
          const entries = pearlOrder.map((k) => {
            const value = dataToUse[k] || 0;
            return [k, typeof value === 'number' ? value : 0];
          });
          
          // Calculate max based on view mode:
          // - All Days: use all-days totals max
          // - Single Day: use the highest single-day max across all days (for consistent scaling)
          let max;
          if (selectedDay !== null && window.dayTotals) {
            // Single day view - use the highest max from any single day for consistent scaling
            let highestSingleDayMax = 1;
            Object.keys(window.dayTotals).forEach(day => {
              const dayTotals = window.dayTotals[day];
              const dayValues = pearlOrder.map((k) => {
                const val = dayTotals[k] || 0;
                return (typeof val === 'number' && !isNaN(val) && isFinite(val)) ? val : 0;
              });
              const dayMax = Math.max(1, ...dayValues);
              if (dayMax > highestSingleDayMax) {
                highestSingleDayMax = dayMax;
              }
            });
            max = highestSingleDayMax;
          } else if (window.allDaysTotals) {
            // All Days view - use all-days totals max
            const allDaysValues = pearlOrder.map((k) => {
              const val = window.allDaysTotals[k] || 0;
              return (typeof val === 'number' && !isNaN(val) && isFinite(val)) ? val : 0;
            });
            max = Math.max(1, ...allDaysValues);
          } else {
            // Fallback to current data max
            const values = entries.map((e) => {
              const val = e[1];
              return (typeof val === 'number' && !isNaN(val) && isFinite(val)) ? val : 0;
            });
            max = Math.max(1, ...values);
          }
          
          if (!isFinite(max) || max <= 0) {
            console.error("Invalid max value:", max);
            return;
          }
          
          // Calculate appropriate step size and number of grid lines based on max value
          let stepSize, numSteps;
          if (max <= 1) {
            stepSize = 1;
            numSteps = 1; // Show 0 and 1
          } else if (max <= 5) {
            stepSize = 1;
            numSteps = max; // One line per integer (0, 1, 2, 3, 4, 5)
          } else if (max <= 10) {
            stepSize = 2;
            numSteps = Math.ceil(max / stepSize);
          } else if (max <= 50) {
            stepSize = 10;
            numSteps = Math.ceil(max / stepSize);
          } else if (max <= 100) {
            stepSize = 20;
            numSteps = 5;
          } else if (max <= 500) {
            stepSize = 100;
            numSteps = 5;
          } else {
            // For larger values, use 5 grid lines
            stepSize = Math.ceil(max / 5);
            // Round stepSize to a nice number
            const niceSteps = [1, 2, 5, 10, 20, 50, 100, 200, 500, 1000, 2000, 5000, 10000];
            stepSize = niceSteps.find(s => s >= stepSize) || stepSize;
            numSteps = 5;
          }
          
          // Calculate actual max (rounded up to nearest step)
          const actualMax = Math.ceil(max / stepSize) * stepSize;
          
          const padding = { top: 40, right: 20, bottom: 50, left: 50 };
          const chartWidth = Math.max(0, displayWidth - padding.left - padding.right);
          const chartHeight = Math.max(0, displayHeight - padding.top - padding.bottom);
          const numBars = pearlOrder.length; // 7 bars (6 pearls + empty clams)
          const barWidth = Math.max(0, (chartWidth / numBars) * 0.7);
          const barSpacing = Math.max(0, chartWidth / numBars);
          
          if (chartWidth <= 0 || chartHeight <= 0 || barWidth <= 0) {
            console.error("Invalid chart dimensions:", { chartWidth, chartHeight, barWidth });
            return;
          }
          
          // Reset bar positions for interactivity
          chartBarPositions = [];

        // Draw background
        ctx.fillStyle = "rgba(15, 15, 25, 0.6)";
        ctx.fillRect(0, 0, displayWidth, displayHeight);
        
        // Draw grid lines - adaptive based on max value
        ctx.strokeStyle = "rgba(255, 255, 255, 0.1)";
        ctx.lineWidth = 1;
        
        // Draw grid lines
        for (let i = 0; i <= numSteps; i++) {
          const value = actualMax - (stepSize * i);
          if (value < 0) continue; // Skip negative values
          
          const y = padding.top + chartHeight * (1 - (value / actualMax));
          ctx.beginPath();
          ctx.moveTo(padding.left, y);
          ctx.lineTo(displayWidth - padding.right, y);
          ctx.stroke();

          // Y-axis labels
          ctx.fillStyle = "#aaa";
          ctx.font = "11px sans-serif";
          ctx.textAlign = "right";
          ctx.fillText(value.toLocaleString(), padding.left - 10, y + 4);
        }

          // Draw bars - always show all bars (6 pearl types + empty clams)
        entries.forEach(([k, v], i) => {
            try {
              const x = padding.left + i * barSpacing + (barSpacing - barWidth) / 2;
              const numValue = typeof v === 'number' && !isNaN(v) ? v : 0;
              let barHeight = (numValue / actualMax) * chartHeight;
              
              // Ensure minimum visible height for all bars (even zero values)
              const minHeight = 4;
              if (barHeight < minHeight && numValue === 0) {
                barHeight = 0; // Truly zero bars have no height
              } else if (barHeight < minHeight && numValue > 0) {
                barHeight = minHeight; // Non-zero bars have minimum visibility
              }
              
              const y = padding.top + chartHeight - barHeight;
              
              // Draw bar with gradient - ensure color exists
              const color = pearlColors[k] || "#888888";
              if (barHeight > 0 && isFinite(barHeight) && isFinite(y)) {
                const gradient = ctx.createLinearGradient(x, y, x, y + barHeight);
                gradient.addColorStop(0, hexToRgba(color, 1.0)); // Full opacity at top
                gradient.addColorStop(1, hexToRgba(color, 0.67)); // ~67% opacity at bottom (aa in hex)
                ctx.fillStyle = gradient;
                ctx.fillRect(x, y, barWidth, barHeight);
                
                // Bar border
                ctx.strokeStyle = color;
          ctx.lineWidth = 2;
                ctx.strokeRect(x, y, barWidth, barHeight);
              } else {
                // Draw a thin line for zero values
                ctx.strokeStyle = hexToRgba(color, 0.25); // ~25% opacity (40 in hex)
                ctx.lineWidth = 1;
          ctx.beginPath();
                ctx.moveTo(x, padding.top + chartHeight);
                ctx.lineTo(x + barWidth, padding.top + chartHeight);
          ctx.stroke();
              }
              
              // Value label on top of bar (always show, even for 0)
              ctx.fillStyle = numValue > 0 ? "#fff" : "#888";
              ctx.font = "bold 12px sans-serif";
              ctx.textAlign = "center";
              const labelY = barHeight > 0 ? y - 8 : padding.top + chartHeight - 8;
              ctx.fillText(
                numValue.toLocaleString(),
                x + barWidth / 2,
                labelY
              );
              
              // X-axis label (pearl name)
              ctx.fillStyle = numValue > 0 ? "#ccc" : "#666";
              ctx.font = "11px sans-serif";
              ctx.textAlign = "center";
              const labelX = x + barWidth / 2;
              const labelYBottom = displayHeight - padding.bottom + 20;
              ctx.save();
              ctx.translate(labelX, labelYBottom);
              ctx.rotate(-Math.PI / 4);
              ctx.fillText(k.replace(" Pearl", ""), 0, 0);
              ctx.restore();
              
              // Store bar position for interactivity (store full bar area including clickable region)
              chartBarPositions.push({
                type: k,
                value: numValue,
                x: x,
                y: padding.top,
                width: barWidth,
                height: chartHeight,
                centerX: x + barWidth / 2
              });
            } catch (err) {
              console.error(`Error drawing bar for ${k}:`, err);
            }
          });
          
          // Draw axis lines
          ctx.strokeStyle = "rgba(255, 255, 255, 0.3)";
          ctx.lineWidth = 2;
          // X-axis
          ctx.beginPath();
          ctx.moveTo(padding.left, padding.top + chartHeight);
          ctx.lineTo(displayWidth - padding.right, padding.top + chartHeight);
          ctx.stroke();
          // Y-axis
          ctx.beginPath();
          ctx.moveTo(padding.left, padding.top);
          ctx.lineTo(padding.left, padding.top + chartHeight);
          ctx.stroke();
          
          // Add mouse event listeners for interactivity (after all drawing is complete)
          setupChartInteractivity(c, totals, days, selectedDay);
        } catch (error) {
          console.error("Error drawing chart:", error);
        }
      }

      function setupChartInteractivity(canvas, totals, days, selectedDay = null) {
        const tooltip = document.getElementById("chartTooltip");
        if (!tooltip) return;

        // Remove existing listeners if any
        canvas.removeEventListener("mousemove", handleChartMouseMove);
        canvas.removeEventListener("mouseleave", handleChartMouseLeave);
        canvas.removeEventListener("click", handleChartClick);

        // Mouse move handler
        function handleChartMouseMove(event) {
          const rect = canvas.getBoundingClientRect();
          const x = event.clientX - rect.left;
          const y = event.clientY - rect.top;

          // Find which bar is being hovered
          const hoveredBar = chartBarPositions.find(bar => {
            return x >= bar.x && x <= bar.x + bar.width && 
                   y >= bar.y && y <= bar.y + bar.height;
          });

          if (hoveredBar) {
            const totalDrops = Object.values(totals).reduce((a, b) => a + b, 0);
            const percent = totals[hoveredBar.type] && totalDrops > 0
              ? ((totals[hoveredBar.type] / totalDrops) * 100).toFixed(2)
              : "0.00";
            
            let tooltipContent = `
              <strong>${hoveredBar.type}</strong>
              <small>Total: ${hoveredBar.value.toLocaleString()}</small>
              <small>Percentage: ${percent}%</small>
            `;
            
            // Only show average per day if viewing all days
            if (selectedDay === null) {
              const avgPerDay = days > 0 
                ? (hoveredBar.value / days).toFixed(2)
                : "0.00";
              tooltipContent += `<small>Average drops per day: ${avgPerDay}</small>`;
            }
            
            tooltipContent += `<small style="color: #ffd369; margin-top: 4px; font-size: 0.75rem;">Click to see drops</small>`;
            
            tooltip.innerHTML = tooltipContent;
            
            tooltip.classList.add("active");
            tooltip.style.left = (event.clientX - rect.left + 15) + "px";
            tooltip.style.top = (event.clientY - rect.top - 10) + "px";
            
            // Keep tooltip within bounds
            if (parseFloat(tooltip.style.left) + tooltip.offsetWidth > canvas.width) {
              tooltip.style.left = (event.clientX - rect.left - tooltip.offsetWidth - 15) + "px";
            }
            if (parseFloat(tooltip.style.top) + tooltip.offsetHeight > canvas.height) {
              tooltip.style.top = (event.clientY - rect.top - tooltip.offsetHeight - 10) + "px";
            }
            
            canvas.style.cursor = "pointer";
          } else {
            tooltip.classList.remove("active");
            canvas.style.cursor = "default";
          }
        }

        // Mouse leave handler
        function handleChartMouseLeave() {
          tooltip.classList.remove("active");
          canvas.style.cursor = "default";
        }

        // Click handler
        function handleChartClick(event) {
          const rect = canvas.getBoundingClientRect();
          const x = event.clientX - rect.left;
          const y = event.clientY - rect.top;

          // Find which bar was clicked
          const clickedBar = chartBarPositions.find(bar => {
            return x >= bar.x && x <= bar.x + bar.width && 
                   y >= bar.y && y <= bar.y + bar.height;
          });

          if (clickedBar) {
            // Always use selectedDay if it's not null (viewing a specific day)
            if (selectedDay !== null) {
              showPearlTiming(selectedDay, clickedBar.type);
            } else {
              showTotalPearlTiming(clickedBar.type);
            }
          }
        }

        // Add event listeners
        canvas.addEventListener("mousemove", handleChartMouseMove);
        canvas.addEventListener("mouseleave", handleChartMouseLeave);
        canvas.addEventListener("click", handleChartClick);
      }

      function runSimulation() {
        // Get DOM elements
        const resultsEl = document.getElementById("results");
        const totalSummaryEl = document.getElementById("totalSummary");
        const scrollHintEl = document.getElementById("scrollHint");
        const canvas = document.getElementById("chart");
        
        // Show loading animation
        if (resultsEl) {
          resultsEl.innerHTML = `
            <div class="loading-container">
              <div class="loading-spinner"></div>
              <div class="loading-text">Simulating pearl drops...</div>
            </div>
          `;
        }
        if (totalSummaryEl) totalSummaryEl.innerHTML = '<small>Running simulation...</small>';
        
        // Hide search/filter section during loading
        const searchFilterSection = document.getElementById("searchFilterSection");
        if (searchFilterSection) {
          searchFilterSection.style.display = "none";
        }
        
        // Clear canvas
        if (canvas) {
          const ctx = canvas.getContext("2d");
          ctx.clearRect(0, 0, canvas.width, canvas.height);
        }
        
        // Disable button during simulation
        const simulateButton = document.getElementById("simulateButton");
        if (simulateButton) {
          simulateButton.disabled = true;
          simulateButton.textContent = "Running...";
        }
        
        // Use setTimeout to allow UI to update with loading animation
        setTimeout(() => {
        // Show scroll hint
          if (scrollHintEl) scrollHintEl.style.display = "block";

          // Clear previous results (loading animation will be replaced)
          if (resultsEl) resultsEl.innerHTML = "";
          if (totalSummaryEl) totalSummaryEl.innerHTML = '<small>Run a simulation to populate totals.</small>';
        
          // Reset totals
        let totals = {};
        Object.keys(pearlImages).forEach((k) => (totals[k] = 0));

        const clams = +clamsPerDay.value;
          let days = +daysToSim.value;
          
          // Validate days: must be between 1 and 365
          if (days < 1) days = 1;
          if (days > 365) days = 365;
          if (daysToSim.value != days) {
            daysToSim.value = days;
          }

          const laps = clams / 41;
          const minutesPerDay = (clams / 41) * 5;

        const pearlOrder = [
          "Empty Clam",
          "White Pearl",
          "Green Pearl",
          "Blue Pearl",
          "Purple Pearl",
          "Gold Pearl",
          "Black Pearl",
        ];

          // Store timing data for each pearl type by day
          const pearlTimingData = {};
          // Store all drops in chronological order for each day
          const dayChronologicalData = {};

        for (let d = 1; d <= days; d++) {
          let day = {};
            // Track when each pearl was obtained this day
            const dayPearlTimings = {};
            // Track all drops in chronological order for this day
            const chronologicalDrops = [];

          for (let i = 0; i < clams; i++) {
            const r = rollOneClam();
            day[r] = (day[r] || 0) + 1;
            totals[r]++;
              
              // Track timing for each pearl drop
              if (!dayPearlTimings[r]) {
                dayPearlTimings[r] = [];
              }
              // Calculate: time from start of this day (not cumulative)
              const timeFromDayStart = ((i + 1) / 41) * 5;
              // Also track cumulative for time since previous calculations
              const totalClamsSoFar = (d - 1) * clams + (i + 1);
              const cumulativeTimeMinutes = (totalClamsSoFar / 41) * 5;
              const dropData = {
                type: r,
                clam: totalClamsSoFar,
                timeMinutes: timeFromDayStart, // Time from start of this day
                cumulativeTimeMinutes: cumulativeTimeMinutes, // For calculating time since previous
                day: d,
                clamInDay: i + 1
              };
              dayPearlTimings[r].push(dropData);
              chronologicalDrops.push(dropData);
            }

            // Store timing data for this day
            pearlTimingData[d] = dayPearlTimings;
            dayChronologicalData[d] = chronologicalDrops;
            
            // Store totals for this day
            const dayTotalsCopy = {};
            Object.keys(pearlImages).forEach((k) => (dayTotalsCopy[k] = day[k] || 0));
            if (!window.dayTotals) window.dayTotals = {};
            window.dayTotals[d] = dayTotalsCopy;

          // ðŸ”¹ BUILD DAY CARD
            // Calculate total drops for this day for tooltip
            const totalDayDrops = Object.values(day).reduce((a, b) => a + b, 0);
            const dayTooltip = `Day ${d}: ${totalDayDrops} total drops across ${Object.keys(day).length} types. Click to see all drops in order.`;
            
            // Create comma-separated list of pearl types for filtering
            const pearlTypesInDay = Object.keys(day).join(',');
            
            // Find the best (rarest) pearl on this day
            // Pearl colors for top border accent
            const pearlColors = {
              "White Pearl": "#e0e0e0",
              "Green Pearl": "#4caf50",
              "Blue Pearl": "#2196f3",
              "Purple Pearl": "#9c27b0",
              "Gold Pearl": "#ffd700",
              "Black Pearl": "#333333"
            };
            
            let bestPearl = null;
            let bestPearlIndex = -1;
            for (let k of pearlOrder) {
              if (day[k] && pearlColors[k]) {
                const index = pearlOrder.indexOf(k);
                if (index > bestPearlIndex) {
                  bestPearlIndex = index;
                  bestPearl = k;
                }
              }
            }
            
            const borderColor = bestPearl ? pearlColors[bestPearl] : "transparent";
            const borderStyle = bestPearl ? `border-top: 3px solid ${borderColor};` : "";
            
          let card = `
      <div class="day-box" data-day="${d}" data-pearl-types="${pearlTypesInDay}" onclick="showDayTiming(${d})" style="cursor: pointer; ${borderStyle}" data-tooltip="${dayTooltip.replace(/"/g, '&quot;')}">
        <h3>Day ${d}</h3>
        <small>Laps: ${laps.toFixed(2)} | Time: ${minutesPerDay.toFixed(2)} min</small>
        <div class="pearls-grid">
    `;

          for (let k of pearlOrder) {
            if (!day[k]) continue;
              const pearlKey = `day-${d}-${k}`;
              const count = day[k];
              const percent = totalDayDrops > 0 ? ((count / totalDayDrops) * 100).toFixed(1) : "0";
              const pearlTooltip = `${k}: ${count} drop${count === 1 ? '' : 's'} on Day ${d} (${percent}% of this day's drops). Click for timing details.`;
              
            card += `
        <div class="pearl" onclick="event.stopPropagation(); showPearlTiming(${d}, '${k.replace(/'/g, "\\'")}')" data-pearl-type="${k}" data-day="${d}" data-tooltip="${pearlTooltip.replace(/"/g, '&quot;')}">
          <img src="${pearlImages[k]}">
          <span>${k}: ${day[k]}</span>
        </div>`;
          }

          card += `</div></div>`;
            if (resultsEl) resultsEl.innerHTML += card;
        }

          // Add event listeners to handle tooltip priority
          // Hide day-box tooltips when hovering anywhere in the pearls-grid area
          setTimeout(() => {
            const allPearlsGrids = document.querySelectorAll('.pearls-grid');
            allPearlsGrids.forEach(grid => {
              const dayBox = grid.closest('.day-box');
              if (dayBox) {
                // Hide day-box tooltip when entering pearls-grid area
                grid.addEventListener('mouseenter', () => {
                  dayBox.classList.add('pearl-hovered');
                });
                // Show day-box tooltip again when leaving pearls-grid area
                grid.addEventListener('mouseleave', () => {
                  dayBox.classList.remove('pearl-hovered');
                });
              }
            });
            
            // Show search/filter section and populate filters
            populateFilters();
            setupSearchAndFilters();
          }, 100);

          // Store timing data globally for modal access
          window.pearlTimingData = pearlTimingData;
          window.dayChronologicalData = dayChronologicalData;
          
          // Store all-days totals for filtering
          window.allDaysTotals = totals;
          window.allDays = days;

          // ðŸ”¹ DRAW CHART (with a small delay to ensure canvas is ready)
          setTimeout(() => {
            drawChart(totals, days);
            updateDayFilterDropdown(days);
          }, 50);

        // ðŸ”¹ TOTAL SUMMARY
        updateSummary(null, clams, days);
          
          // Update button text to "Rerun Simulation" and re-enable
          if (simulateButton) {
            simulateButton.textContent = "Rerun Simulation";
            simulateButton.disabled = false;
          }
        }, 100); // End of setTimeout - allows loading animation to render
      }

      // Day Filter Functions
      function updateSummary(selectedDay, clams, days) {
        const totalSummaryEl = document.getElementById("totalSummary");
        if (!totalSummaryEl) return;
        
        let totalClams, totalLaps, totalMinutes, totalHours, titleText, clickHandler;
        
        if (selectedDay && window.dayTotals && window.dayTotals[selectedDay]) {
          // Single day summary
          totalClams = clams;
          totalLaps = clams / 41;
          totalMinutes = totalLaps * 5;
          totalHours = (totalMinutes / 60).toFixed(2);
          titleText = `Day ${selectedDay} Summary <small style="color: #aaa; font-size: 0.8rem; font-weight: normal;">(Click to see all drops)</small>`;
          clickHandler = `showDayTiming(${selectedDay})`;
        } else {
          // All days summary
          totalClams = clams * days;
          totalLaps = (clams / 41) * days;
          totalMinutes = totalLaps * 5;
          totalHours = (totalMinutes / 60).toFixed(2);
          titleText = `Summary <small style="color: #aaa; font-size: 0.8rem; font-weight: normal;">(Click to see all drops)</small>`;
          clickHandler = `showAllDaysTiming()`;
        }
        
        const totalHTML = `
          <div onclick="${clickHandler}" style="background: rgba(20, 20, 30, 0.6); padding: 16px; border-radius: 8px; margin-top: 16px; cursor: pointer; transition: all 0.2s ease;" onmouseover="this.style.background='rgba(25, 25, 35, 0.7)'" onmouseout="this.style.background='rgba(20, 20, 30, 0.6)'">
            <h4 style="color: #ffd369; margin: 0 0 12px 0; font-size: 1.1rem;">${titleText}</h4>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 12px;">
              <div><small style="color: #aaa;">Total laps:</small><br><strong style="color: #ffd369;">${totalLaps.toFixed(2)}</strong></div>
              <div><small style="color: #aaa;">Total time:</small><br><strong style="color: #ffd369;">${totalHours} hours</strong></div>
              <div><small style="color: #aaa;">Total clams opened:</small><br><strong style="color: #ffd369;">${totalClams.toLocaleString()}</strong></div>
            </div>
          </div>
        `;
        totalSummaryEl.innerHTML = totalHTML;
      }
      
      function updateDayFilterDropdown(days) {
        const dropdownContainer = document.getElementById("dayFilterDropdown");
        const selectElement = document.getElementById("dayFilterSelect");
        if (!dropdownContainer || !selectElement) return;
        
        selectElement.innerHTML = '';
        
        // Add "All Days" option
        const allDaysOption = document.createElement("option");
        allDaysOption.value = "all";
        allDaysOption.textContent = "All Days";
        allDaysOption.selected = true;
        selectElement.appendChild(allDaysOption);
        
        // Add individual day options
        for (let d = 1; d <= days; d++) {
          const dayOption = document.createElement("option");
          dayOption.value = d;
          dayOption.textContent = `Day ${d}`;
          selectElement.appendChild(dayOption);
        }
        
        // Show dropdown container
        dropdownContainer.style.display = "block";
        
        // Add event listener for dropdown change
        selectElement.onchange = function() {
          const selectedValue = this.value;
          const selectedDay = selectedValue === "all" ? null : parseInt(selectedValue);
          handleDayFilterChange(selectedDay);
        };
      }
      
      function handleDayFilterChange(selectedDay) {
        // Update chart
        const totals = selectedDay && window.dayTotals && window.dayTotals[selectedDay]
          ? window.dayTotals[selectedDay]
          : window.allDaysTotals;
        const days = window.allDays || 50;
        drawChart(totals, days, selectedDay);
        
        // Update summary
        const clamsPerDay = document.getElementById("clamsPerDay");
        const daysToSim = document.getElementById("daysToSim");
        const clams = clamsPerDay ? +clamsPerDay.value : 150;
        const totalDays = daysToSim ? +daysToSim.value : 50;
        updateSummary(selectedDay, clams, totalDays);
      }

      // Filter Functions
      function populateFilters() {
        const filtersContainer = document.getElementById("pearlFilters");
        const searchSection = document.getElementById("searchFilterSection");
        const daySearch = document.getElementById("daySearch");
        
        if (!filtersContainer || !searchSection) return;
        
        // Save current filter state before repopulating
        const savedFilterState = {};
        const existingCheckboxes = filtersContainer.querySelectorAll('input[type="checkbox"]');
        existingCheckboxes.forEach(checkbox => {
          savedFilterState[checkbox.value] = checkbox.checked;
        });
        
        // Save search value
        const savedSearchValue = daySearch ? daySearch.value : "";
        
        // Show search/filter section
        searchSection.style.display = "block";
        
        // Get all pearl types from pearlImages
        const pearlOrder = [
          "Empty Clam",
          "White Pearl",
          "Green Pearl",
          "Blue Pearl",
          "Purple Pearl",
          "Gold Pearl",
          "Black Pearl",
        ];
        
        filtersContainer.innerHTML = "";
        
        pearlOrder.forEach(pearlType => {
          const filterItem = document.createElement("div");
          filterItem.className = "pearl-filter-item";
          
          const checkbox = document.createElement("input");
          checkbox.type = "checkbox";
          checkbox.id = `filter-${pearlType.replace(/\s+/g, '-')}`;
          checkbox.value = pearlType;
          // Restore saved state, or default to true if no saved state
          checkbox.checked = savedFilterState.hasOwnProperty(pearlType) ? savedFilterState[pearlType] : true;
          
          const label = document.createElement("label");
          label.htmlFor = checkbox.id;
          label.innerHTML = `<img src="${pearlImages[pearlType]}" alt="${pearlType}">${pearlType}`;
          
          // Make entire filter item clickable - clicking anywhere toggles the checkbox
          filterItem.addEventListener('click', (e) => {
            // If clicking directly on checkbox, let its native behavior handle it (change event will fire)
            if (e.target === checkbox) {
              return; // Checkbox change event listener will handle filterResults
            }
            // Toggle checkbox when clicking anywhere else on the item (label, image, padding, etc.)
            e.preventDefault();
            checkbox.checked = !checkbox.checked;
            filterResults();
          });
          
          filterItem.appendChild(checkbox);
          filterItem.appendChild(label);
          filtersContainer.appendChild(filterItem);
        });
        
        // Restore search value
        if (daySearch && savedSearchValue) {
          daySearch.value = savedSearchValue;
        }
      }

      function setupSearchAndFilters() {
        const daySearch = document.getElementById("daySearch");
        
        if (daySearch) {
          daySearch.addEventListener('input', filterResults);
        }
        
        // Get checkboxes after they're created by populateFilters
        setTimeout(() => {
          const checkboxes = document.querySelectorAll('#pearlFilters input[type="checkbox"]');
          checkboxes.forEach(checkbox => {
            checkbox.addEventListener('change', filterResults);
          });
          
          // Apply saved filter state after setting up listeners
          filterResults();
        }, 10);
      }

      function filterResults() {
        const daySearch = document.getElementById("daySearch");
        const allCheckboxes = document.querySelectorAll('#pearlFilters input[type="checkbox"]');
        const checkedBoxes = document.querySelectorAll('#pearlFilters input[type="checkbox"]:checked');
        const allDayBoxes = document.querySelectorAll('.day-box');
        const filterResultsEl = document.getElementById("filterResults");
        
        const searchTerm = daySearch ? daySearch.value.toLowerCase().trim() : '';
        const selectedPearls = Array.from(checkedBoxes).map(cb => cb.value);
        
        let visibleCount = 0;
        
        allDayBoxes.forEach(dayBox => {
          const dayNum = dayBox.getAttribute('data-day');
          const pearlTypes = dayBox.getAttribute('data-pearl-types') || '';
          const pearlTypesList = pearlTypes.split(',').filter(t => t.trim());
          
          // Check search term (search by day number or pearl type names in the day)
          let matchesSearch = true;
          if (searchTerm) {
            const dayMatches = dayNum && dayNum.toLowerCase().includes(searchTerm);
            const pearlMatches = pearlTypesList.some(type => 
              type.toLowerCase().includes(searchTerm)
            );
            matchesSearch = dayMatches || pearlMatches;
          }
          
          // Check if day has at least one selected pearl type
          // If no pearls are selected, hide all days
          const hasSelectedPearl = selectedPearls.length === 0 ? false : selectedPearls.some(pearl => 
            pearlTypesList.includes(pearl)
          );
          
          // Show/hide day box
          if (matchesSearch && hasSelectedPearl) {
            dayBox.style.display = "block";
            visibleCount++;
          } else {
            dayBox.style.display = "none";
          }
        });
        
        // Update filter results count
        if (filterResultsEl) {
          const totalCheckboxes = allCheckboxes.length;
          if (visibleCount === allDayBoxes.length && !searchTerm && selectedPearls.length === totalCheckboxes) {
            filterResultsEl.textContent = "";
          } else {
            filterResultsEl.textContent = `Showing ${visibleCount} of ${allDayBoxes.length} days`;
          }
        }
      }

      function toggleSearchFilter() {
        const content = document.getElementById("searchFilterContent");
        const toggle = document.getElementById("searchFilterToggle");
        
        if (content && toggle) {
          const isHidden = content.style.display === "none";
          content.style.display = isHidden ? "block" : "none";
          toggle.classList.toggle("rotated", isHidden);
        }
      }

      function showPearlTiming(day, pearlType) {
        const modal = document.getElementById("pearlModal");
        const modalTitle = document.getElementById("modalTitle");
        const modalDescription = document.getElementById("modalDescription");
        const modalContent = document.getElementById("modalContent");
        
        if (!modal || !window.pearlTimingData) return;
        
        // Get timing data for this pearl type on this day
        const dayData = window.pearlTimingData[day];
        if (!dayData || !dayData[pearlType] || dayData[pearlType].length === 0) {
          modalTitle.textContent = `${pearlType} - Day ${day}`;
          modalDescription.textContent = "No drops found on this day.";
          modalContent.innerHTML = "<p style='color: #aaa;'>No timing data available for this pearl type on this day.</p>";
        } else {
          const timings = dayData[pearlType];
          
          modalTitle.textContent = `${pearlType} - Day ${day}`;
          modalDescription.textContent = `Found ${timings.length} ${timings.length === 1 ? 'drop' : 'drops'} on Day ${day}:`;
          
          let html = "";
          
            timings.forEach((timing, index) => {
              // Use time from start of day (not cumulative)
              const hours = Math.floor(timing.timeMinutes / 60);
              const minutes = (timing.timeMinutes % 60).toFixed(1);
              const timeDisplay = hours > 0 
                ? `${hours}h ${minutes}min` 
                : `${minutes}min`;
              
              // Calculate cumulative time from start of simulation
              const cumHours = Math.floor(timing.cumulativeTimeMinutes / 60);
              const cumMinutes = (timing.cumulativeTimeMinutes % 60).toFixed(1);
              const cumTimeDisplay = cumHours > 0 
                ? `${cumHours}h ${cumMinutes}min` 
                : `${cumMinutes}min`;
              
              html += `
                <div class="pearl-timing-item">
                  <img src="${pearlImages[pearlType]}" alt="${pearlType}">
                  <div class="pearl-timing-item-content">
                    <strong>Drop #${index + 1}</strong>
                    <small>
                      ${timing.clamInDay}${timing.clamInDay === 1 ? 'st' : timing.clamInDay === 2 ? 'nd' : timing.clamInDay === 3 ? 'rd' : 'th'} clam on Day ${day}<br>
                      Time from start of day: ${timeDisplay}<br>
                      <span style="color: #aaa;">Time from start of simulation: ${cumTimeDisplay}</span>
                    </small>
                  </div>
      </div>
    `;
            });
          
          modalContent.innerHTML = html;
        }
        
        modal.classList.add("active");
      }

      function showDayTiming(day) {
        const modal = document.getElementById("pearlModal");
        const modalTitle = document.getElementById("modalTitle");
        const modalDescription = document.getElementById("modalDescription");
        const modalContent = document.getElementById("modalContent");
        
        if (!modal || !window.dayChronologicalData) return;
        
        // Get chronological data for this day
        const dayData = window.dayChronologicalData[day];
        if (!dayData || dayData.length === 0) {
          modalDescription.textContent = "";
          modalContent.innerHTML = "<p style='color: #aaa;'>No data available for this day.</p>";
        } else {
          modalTitle.textContent = `Day ${day} - All Drops`;
          modalDescription.textContent = `${dayData.length} drops on Day ${day} in chronological order:`;
          
          let html = "";
          
          dayData.forEach((drop, index) => {
            const hours = Math.floor(drop.timeMinutes / 60);
            const minutes = (drop.timeMinutes % 60).toFixed(1);
            const timeDisplay = hours > 0 
              ? `${hours}h ${minutes}min` 
              : `${minutes}min`;
            
            // Calculate cumulative time from start of simulation
            const cumHours = Math.floor(drop.cumulativeTimeMinutes / 60);
            const cumMinutes = (drop.cumulativeTimeMinutes % 60).toFixed(1);
            const cumTimeDisplay = cumHours > 0 
              ? `${cumHours}h ${cumMinutes}min` 
              : `${cumMinutes}min`;
            
            html += `
              <div class="pearl-timing-item">
                <img src="${pearlImages[drop.type]}" alt="${drop.type}">
                <div class="pearl-timing-item-content">
                  <strong>#${index + 1} - ${drop.type}</strong>
                  <small>
                    ${drop.clamInDay}${drop.clamInDay === 1 ? 'st' : drop.clamInDay === 2 ? 'nd' : drop.clamInDay === 3 ? 'rd' : 'th'} clam on Day ${day}<br>
                    Time from start of day: ${timeDisplay}<br>
                    <span style="color: #aaa;">Time from start of simulation: ${cumTimeDisplay}</span>
                  </small>
                </div>
              </div>
            `;
          });
          
          modalContent.innerHTML = html;
        }
        
        modal.classList.add("active");
      }

      function showTotalPearlTiming(pearlType) {
        const modal = document.getElementById("pearlModal");
        const modalTitle = document.getElementById("modalTitle");
        const modalDescription = document.getElementById("modalDescription");
        const modalContent = document.getElementById("modalContent");
        
        if (!modal || !window.pearlTimingData) return;
        
        // Collect all drops of this pearl type across all days
        const allDrops = [];
        Object.keys(window.pearlTimingData).forEach(day => {
          const dayData = window.pearlTimingData[day];
          if (dayData[pearlType]) {
            dayData[pearlType].forEach(drop => {
              allDrops.push({
                ...drop,
                day: parseInt(day)
              });
            });
          }
        });
        
        // Sort by cumulative time to get chronological order
        allDrops.sort((a, b) => a.cumulativeTimeMinutes - b.cumulativeTimeMinutes);
        
        if (allDrops.length === 0) {
          modalTitle.textContent = `${pearlType} - All Days`;
          modalDescription.textContent = "No drops found across all days.";
          modalContent.innerHTML = "<p style='color: #aaa;'>No drops found for this pearl type.</p>";
        } else {
          modalTitle.textContent = `${pearlType} - All Days`;
          modalDescription.textContent = `Found ${allDrops.length} ${allDrops.length === 1 ? 'drop' : 'drops'} across all ${Object.keys(window.pearlTimingData).length} days:`;
          
          let html = "";
          
          allDrops.forEach((drop, index) => {
            const hours = Math.floor(drop.timeMinutes / 60);
            const minutes = (drop.timeMinutes % 60).toFixed(1);
            const timeDisplay = hours > 0 
              ? `${hours}h ${minutes}min` 
              : `${minutes}min`;
            
            // Calculate cumulative time from start of simulation
            const cumHours = Math.floor(drop.cumulativeTimeMinutes / 60);
            const cumMinutes = (drop.cumulativeTimeMinutes % 60).toFixed(1);
            const cumTimeDisplay = cumHours > 0 
              ? `${cumHours}h ${cumMinutes}min` 
              : `${cumMinutes}min`;
            
            html += `
              <div class="pearl-timing-item">
                <img src="${pearlImages[pearlType]}" alt="${pearlType}">
                <div class="pearl-timing-item-content">
                  <strong>#${index + 1} - Day ${drop.day}</strong>
                  <small>
                    ${drop.clamInDay}${drop.clamInDay === 1 ? 'st' : drop.clamInDay === 2 ? 'nd' : drop.clamInDay === 3 ? 'rd' : 'th'} clam on Day ${drop.day}<br>
                    Time from start of day: ${timeDisplay}<br>
                    <span style="color: #aaa;">Time from start of simulation: ${cumTimeDisplay}</span>
                  </small>
                </div>
              </div>
            `;
          });
          
          modalContent.innerHTML = html;
        }
        
        modal.classList.add("active");
      }

      function showAllDaysTiming() {
        const modal = document.getElementById("pearlModal");
        const modalTitle = document.getElementById("modalTitle");
        const modalDescription = document.getElementById("modalDescription");
        const modalContent = document.getElementById("modalContent");
        
        if (!modal || !window.dayChronologicalData) return;
        
        // Collect all drops across all days in chronological order
        const allDrops = [];
        Object.keys(window.dayChronologicalData).forEach(day => {
          const dayData = window.dayChronologicalData[day];
          dayData.forEach(drop => {
            allDrops.push({
              ...drop,
              day: parseInt(day)
            });
          });
        });
        
        // Sort by cumulative time to get chronological order across all days
        allDrops.sort((a, b) => a.cumulativeTimeMinutes - b.cumulativeTimeMinutes);
        
        if (allDrops.length === 0) {
          modalDescription.textContent = "";
          modalContent.innerHTML = "<p style='color: #aaa;'>No data available.</p>";
        } else {
          const totalDays = Object.keys(window.dayChronologicalData).length;
          modalTitle.textContent = `All Days - All Drops`;
          modalDescription.textContent = `${allDrops.length} drops across all ${totalDays} days in chronological order:`;
          
          let html = "";
          
          allDrops.forEach((drop, index) => {
            const hours = Math.floor(drop.timeMinutes / 60);
            const minutes = (drop.timeMinutes % 60).toFixed(1);
            const timeDisplay = hours > 0 
              ? `${hours}h ${minutes}min` 
              : `${minutes}min`;
            
            // Calculate cumulative time from start of simulation
            const cumHours = Math.floor(drop.cumulativeTimeMinutes / 60);
            const cumMinutes = (drop.cumulativeTimeMinutes % 60).toFixed(1);
            const cumTimeDisplay = cumHours > 0 
              ? `${cumHours}h ${cumMinutes}min` 
              : `${cumMinutes}min`;
            
            html += `
              <div class="pearl-timing-item">
                <img src="${pearlImages[drop.type]}" alt="${drop.type}">
                <div class="pearl-timing-item-content">
                  <strong>#${index + 1} - ${drop.type} (Day ${drop.day})</strong>
                  <small>
                    ${drop.clamInDay}${drop.clamInDay === 1 ? 'st' : drop.clamInDay === 2 ? 'nd' : drop.clamInDay === 3 ? 'rd' : 'th'} clam on Day ${drop.day}<br>
                    Time from start of day: ${timeDisplay}<br>
                    <span style="color: #aaa;">Time from start of simulation: ${cumTimeDisplay}</span>
                  </small>
                </div>
              </div>
            `;
          });
          
          modalContent.innerHTML = html;
        }
        
        modal.classList.add("active");
      }

      function closePearlModal() {
        const modal = document.getElementById("pearlModal");
        const modalTitle = document.getElementById("modalTitle");
        const modalDescription = document.getElementById("modalDescription");
        const modalContent = document.getElementById("modalContent");
        
        if (modal) {
          modal.classList.remove("active");
        }
        
        // Clear modal content to prevent lag
        if (modalTitle) {
          modalTitle.textContent = "";
        }
        if (modalDescription) {
          modalDescription.textContent = "";
        }
        if (modalContent) {
          modalContent.innerHTML = "";
        }
      }

      // Close modal when clicking outside
      document.addEventListener("click", function(event) {
        const modal = document.getElementById("pearlModal");
        if (modal && event.target === modal) {
          closePearlModal();
        }
      });

      // Close modal with Escape key
      document.addEventListener("keydown", function(event) {
        if (event.key === "Escape") {
          closePearlModal();
        }
      });

      // Scroll to Top Button
      const scrollToTopBtn = document.getElementById("scrollToTop");
      
      if (scrollToTopBtn) {
        function toggleScrollToTop() {
          if (window.scrollY > 300) {
            scrollToTopBtn.classList.add("active");
          } else {
            scrollToTopBtn.classList.remove("active");
          }
        }

        window.addEventListener("scroll", toggleScrollToTop);
        
        scrollToTopBtn.addEventListener("click", function() {
          window.scrollTo({
            top: 0,
            behavior: "smooth"
          });
        });
      }
    </script>
  </body>
</html>
